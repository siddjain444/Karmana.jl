var documenterSearchIndex = {"docs":
[{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"EditURL = \"https://github.com/xKDR/Karmana.jl/blob/main/examples/geodesic.jl\"","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"Karmana's geodesic utilities","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"This example explores some of the geodesic utilities which Karmana provides.","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"A geodesic path is the shortest path from point A to point B on the surface of the Earth, taking into account its curvature.  It is the distance \"as the crow flies\".","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"using CairoMakie, Karmana","category":"page"},{"location":"examples/geodesic/#Geodetic-circles","page":"Capex geodesic utilities","title":"Geodetic circles","text":"","category":"section"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"A \"geodetic circle\" is the locus of all points which are physically radius away from the center.","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"Here's one around Mumbai:","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"initial_line = Karmana.get_geodetic_circle(72, 19, 9000) # 9km radius around Mumbai\nlines(initial_line; axis = (; aspect = DataAspect()))","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"This is another geodetic circle at a 20km radius around Mumbai.","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"fig, ax, circ_plt = lines(Karmana.get_geodetic_circle(72, 50, 20_000); linewidth = 2, axis = (; aspect = DataAspect()))\ncent_plot = scatter!(ax, [Point2f(72, 50)])\nfig","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"Note the difference in the physical width of the two circles. This is because the Earth is not a perfect sphere, but is slightly flattened at the poles.","category":"page"},{"location":"examples/geodesic/#Geodetic-width-polylines","page":"Capex geodesic utilities","title":"Geodetic width polylines","text":"","category":"section"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"Karmana can geodetically expand lines to polygons along the same path as the line, with some fixed width.","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"poly_line = Karmana.line_to_geodetic_width_poly(Point2f.(LinRange(0, 12, 100), 50 .* sin.(LinRange(0, 12, 100))), 20_000)\npoly(poly_line; aspect = DataAspect())","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"Because of the aspect ratio of the plot, the polygon is thin when going horizontally, and thick when going vertically.","category":"page"},{"location":"examples/geodesic/#Annular-rings","page":"Capex geodesic utilities","title":"Annular rings","text":"","category":"section"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"Rasters.rasterize works on this polygon!  This is an \"annular ring\", i.e., a circle with a hole in the middle.","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"annular_polygon = Makie.GeometryBasics.Polygon(\n    Karmana.get_geodetic_circle(72, 50, 90_000),\n    [reverse(Karmana.get_geodetic_circle(72, 50, 20_000))] # note the `reverse` here - this is for the intersection fill rule.\n)\n\npoly(annular_polygon; axis = (; aspect = DataAspect()))","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"You can see how the ring was warped because of its latitude.","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"These are the building blocks for the annular ring and geodetic utilities which Karmana exposes.","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"using CSV, DataFrames, Statistics\n\n\n# Let's get some interesting data, you could put nightlights here as well.\n\nxs, ys = dims(nightlights_raster)\nnightlights_bbox = Makie.BBox(extrema(xs)..., extrema(ys)...)\n\ncity_dataset = CSV.read(\"/Users/anshul/Downloads/simplemaps_worldcities_basicv1.75/worldcities.csv\", DataFrame)\n\nlats, lons = city_dataset[!, :lat], city_dataset[!, :lng]\n\nindia_cities = dropmissing(city_dataset[in.(Point2f.(lons, lats), (nightlights_bbox,)), :])\nsort!(india_cities, :population; order = Base.Reverse)\n\n# Top 8 cities in India by population\nindia_cities.city_positions = Point2{Float64}.(india_cities[!, :lng], india_cities[!, :lat])\n\none_light_from_ring = Karmana.annular_ring.(Statistics.mean, view(nightlights_raster, :, :, 1), india_cities.city_positions[1]... #= lon, lat=#, 15000, 3000)\n\nlights_from_ring = Karmana.annular_ring.(Statistics.mean, nightlights_raster, india_cities.city_positions[1]..., 15000, 3000)\n\n# plot\n\nf, a, p = lines(lights_from_ring, label = \"Mean radiance\", axis = (; title = \"Mean nighttime light radiance around Mumbai over time\", xlabel = \"Time (months)\", ylabel = \"Radiance\"))\naxislegend(a, position = :lt)\na.title = \"Mean nighttime light radiance around Delhi over time\"\nf","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"","category":"page"},{"location":"examples/geodesic/","page":"Capex geodesic utilities","title":"Capex geodesic utilities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"artifacts/#Artifacts","page":"Artifacts","title":"Artifacts","text":"","category":"section"},{"location":"artifacts/","page":"Artifacts","title":"Artifacts","text":"Karmana currently uses one artifact, the India shapefile found in https://github.com/xKDR/india-maps.","category":"page"},{"location":"artifacts/","page":"Artifacts","title":"Artifacts","text":"To update this, you can make a new release of india-maps, update Karmana.__init__ with the file path, and use ArtifactUtils.jl's add_artifact! function to add it to the repo, under the name india_shapefile.  ","category":"page"},{"location":"artifacts/","page":"Artifacts","title":"Artifacts","text":"Other artifacts should be handled similarly (i.e, a gitrepo from which we download release tarballs).","category":"page"},{"location":"artifacts/#Updating-the-india_shapefile-artifact","page":"Artifacts","title":"Updating the india_shapefile artifact","text":"","category":"section"},{"location":"artifacts/","page":"Artifacts","title":"Artifacts","text":"As easy as 1, 2, 3!","category":"page"},{"location":"artifacts/","page":"Artifacts","title":"Artifacts","text":"Remove the india_shapefile entry from Karmana.jl's Artifacts.toml (literally, delete that text.)\nRun add_artifact!(joinpath(\"$(dirname(pathof(Karmana)))\", \"Artifacts.toml\"), \"india_shapefile\", \"https://github.com/xKDR/india-maps/archive/refs/tags/v0.2.0.tar.gz\") but replace the URL with the new URL for the release tarball.\nPush your changes to the Karmana.jl repo!","category":"page"},{"location":"examples/labelling/","page":"-","title":"-","text":"EditURL = \"https://github.com/xKDR/Karmana.jl/blob/main/examples/labelling.jl\"","category":"page"},{"location":"examples/labelling/","page":"-","title":"-","text":"using Polylabel\nusing Karmana, CairoMakie","category":"page"},{"location":"examples/labelling/","page":"-","title":"-","text":"Here, we create a map with all states labelled at their \"poles of inaccessibility\", computed by Polylabel.jl.","category":"page"},{"location":"examples/labelling/","page":"-","title":"-","text":"This is a very simple example, but it shows how to use Karmana.jl to create a map with labels.","category":"page"},{"location":"examples/labelling/","page":"-","title":"-","text":"","category":"page"},{"location":"examples/labelling/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"EditURL = \"https://github.com/xKDR/Karmana.jl/blob/main/examples/ternary.jl\"","category":"page"},{"location":"examples/ternary/#Ternary-colormaps","page":"Ternary colormaps","title":"Ternary colormaps","text":"","category":"section"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"using Karmana, CairoMakie, TernaryColormaps","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Ternary diagrams are plots on the plane x + y + z = 1, in Cartesian space.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"A ternary colormap is a sampler which takes as input a coordinate for which x + y + z = 1, and returns a color.   The color is specified by three color gradients, one for each of x, y, z.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"In Karmana, a ternary colormap is created by the TernaryColormap constructor, which has various keyword arguments that you can see in its documentation.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Here's what a ternary colormap looks like:","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"fig = Figure()\nax, im = Karmana.TernaryColorlegend(fig[1, 1], TernaryColormap())\nfig","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"This is pretty cool, but some of the colors seem wrong.  Let's inspect the data:","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"fig = Figure()\nax = Axis(fig[1, 1]; aspect = AxisAspect(96/71))\nhidedecorations!(ax); hidespines!(ax)\nTernaryDiagrams.ternaryscatter!(ax, (getindex.(data, i) for i in 1:3)...; color = colors, markersize = 30)\n\nternaryaxis!(ax);\n\nfig","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Any ternary colormap can be called like a function to return a color, as in tmap(x, y, z) or tmap(::Point3), where tmap is a TernaryColormap. This handles NaNs and missings by setting their values to zero.","category":"page"},{"location":"examples/ternary/#Using-ternary-colormaps","page":"Ternary colormaps","title":"Using ternary colormaps","text":"","category":"section"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Let's say I have some (fake) survey data across India, with three responses: good, bad, and unsure.  Unsure is not actually in between good and bad, since it can mean a lot of things, so we want to incorporate it as a third variable.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"First, we create some random points:","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"random_data = rand(Point3f, 36)\n\nf, a, p = scatter(random_data)\n\nrotate_cam!(a.scene, π/6, π/6, 0, 0)\n\nf","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Then, we project them onto the x+y+z=1 plane (this is normalizing to the L_1 norm, which is effectively what I said earlier - ensuring that the sum of x, y, and z is 1.)","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"data = LinearAlgebra.normalize.(random_data, 1)\n\nscatter!(a, data; color = :red)\nf\n\ntriplane = mesh!(a, Point3f[(0,0,1), (0, 1, 0), (1, 0, 0)]; color = (:blue, 0.5))\nf","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Now, we can find the colors:","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"colors = tmap.(Point3f.(data))","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"We can even plot this using the indiaoutline recipe, which can take colors in place of values:","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"f, a, p = indiaoutline(:State, 1:36, colors; axis = (aspect = DataAspect(),))","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Let's also add a legend to this:","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"ta, ip = Karmana.TernaryColorlegend(f[1, 2], tmap; xlabel = \"Bad\", ylabel = \"Good\", zlabel = \"Uncertain\")\n\nf\n\nta.width = Relative(0.7)\nf","category":"page"},{"location":"examples/ternary/#What-is-a-ternary-colormap?","page":"Ternary colormaps","title":"What is a ternary colormap?","text":"","category":"section"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"The resulting color is created by adding the colors from each colormap at the value of the variable. So, a color would be defined as xmap(x) + ymap(y) + zmap(z), where the *map functions take in a number and return a color.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"A TernaryColormap is made of three color gradients, xmap, ymap, and zmap.  These are Julia color gradient objects which can be created by the cgrad function - see its documentation for more details.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Let's explore these gradients in more detail:","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"tmap = TernaryColormap()\nfig = Figure()\nwith_theme(Attributes(\n    Colorbar = (\n        vertical = false, flipaxis = false, height = 40,\n        ticks = Makie.LinearTicks(5)\n    ))) do\n    xcb = Colorbar(fig[1, 1], label = \"x\", colorrange = (0, 1), colormap = tmap.xmap)\n    xlb = Label(fig[1, 0], text = \"x\", font = :bold, fontsize = 35, tellheight = false)\n    ycb = Colorbar(fig[2, 1], label = \"y\", colorrange = (0, 1), colormap = tmap.ymap)\n    ylb = Label(fig[2, 0], text = \"y\", font = :bold, fontsize = 35, tellheight = false)\n    zcb = Colorbar(fig[3, 1], label = \"z\", colorrange = (0, 1), colormap = tmap.zmap)\n    zlb = Label(fig[3, 0], text = \"z\", font = :bold, fontsize = 35, tellheight = false)\nend\nfig","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"These are the individual gradients of the ternary colormap.","category":"page"},{"location":"examples/ternary/#Custom-ternary-colormaps","page":"Ternary colormaps","title":"Custom ternary colormaps","text":"","category":"section"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Care must be taken when creating a ternary colormap, to ensure that the colors add up, even at their maximum, to something reasonable.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"For example,","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"fig = Figure()\nax, im = TernaryColorlegend(fig[1, 1], TernaryColormap(cgrad(:Oranges), cgrad(:Purples), cgrad(:Greens)))\nfig","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"This looks white, because the output of the sum of these colors is too high!","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"We can fix this by making the colors darker:","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"ocg = cgrad(:Oranges)\nocg_hsl = ocg.colors.colors .|> Makie.Colors.HSL\nocg_dark = map(x -> Makie.Colors.HSL(x.h, x.s, x.l * 0.3), ocg_hsl) |> cgrad\n\npcg = cgrad(:Purples)\npcg_hsl = pcg.colors.colors .|> Makie.Colors.HSL\npcg_dark = map(x -> Makie.Colors.HSL(x.h, x.s, x.l * 0.3), pcg_hsl) |> cgrad\n\ngcg = cgrad(:Greens)\ngcg_hsl = gcg.colors.colors .|> Makie.Colors.HSL\ngcg_dark = map(x -> Makie.Colors.HSL(x.h, x.s, x.l * 0.3), gcg_hsl) |> cgrad","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Let's see what this gave us.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"fig = Figure()\nax, im = TernaryColorlegend(fig[1, 1], TernaryColormap(ocg_dark, pcg_dark, gcg_dark))\nfig","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Well, it technically works...but isn't that good and won't really show you anything.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"Another option is to use PerceptualColourMaps.jl, by Peter Kovesi (of colorcet fame). This is where Karmana.jl gets its own ternary colour map from.","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"These are perceptually uniform colour gradients, where no one colour looks extra bright or dark. This allows humans to more easily understand what's going on, instead of being led astray by false trends in luminosity (see the many scathing reviews of Matlab's rainbow colormap for more info on this).","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"You can usually generate any colormap by using PerceptuallyUniformColourmaps.equalisecolourmap (note the British English spelling here).","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"TernaryColormap(\n    cgrad([:cyan, :black]),\n    cgrad([:magenta, :black]),\n    cgrad([:yellow, :black]),\n) |> image","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"","category":"page"},{"location":"examples/ternary/","page":"Ternary colormaps","title":"Ternary colormaps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"autodocs/#Miscellaneous-documentation","page":"Autodocs","title":"Miscellaneous documentation","text":"","category":"section"},{"location":"autodocs/","page":"Autodocs","title":"Autodocs","text":"This is a collection of the rest of the docstrings from Karmana.jl; this does not make them public API!","category":"page"},{"location":"autodocs/","page":"Autodocs","title":"Autodocs","text":"Modules = [Karmana]","category":"page"},{"location":"autodocs/#Karmana.Karmana","page":"Autodocs","title":"Karmana.Karmana","text":"Karmana\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)\n\nKarmana.jl is a library which implements utilities to munge CMIE CPHS data and visualize it.  It exposes multiple, orthogonal capabilities.\n\nKarmana's visualization utilities are built on the Makie.jl ecosystem, including the GeoMakie.jl package.\n\nThe package is built to automate some processes to:\n\nRetrieve and process data from the CMIE CPHS and Capex databases\nPlot this data on maps of India.\nCreate coherent and good-looking posters of plots quickly and easily.\n\nInstalling\n\nKarmana.jl is meant to work with CMIE CPHS data, and is not meant to be released to the General registry.\n\nusing Pkg\nPkg.add(url = \"https://github.com/xKDR/Karmana.jl\")\n\nTo add a specific branch or tag, provide the rev = \"branch_name\" keyword argument.\n\nUsage\n\nKarmana.jl implements several orthogonal functions.  For more information, please see the documentation API page, or by running ?funcname in the REPL to access Julia's help mode.\n\nPlotting and visualization\n\ncreate_page(page_size::Symbol, args...; kwargs...): Creates a Makie.jl figure which is optimized for a figure of the appropriate size, along with a \"header\" row (GridLayout) which has a logo and poster title, and a \"footer\" row (GridLayout) which has a description Label, space for a legend or colorbar, and a QR code with a customizable link.  See the documentation for more!\nindiaoutline!(admin_level::Symbol, ids, vals): A Makie.jl recipe which is able to plot at one of three admin levels (:State, :HR, and :District) - and display the other admin levels' borders.\nTernaryColormap(xgrad, ygrad, zgrad), which creates a \"ternary colormap\" that can be called on x, y, z values for which x + y + z = 1, and returns a ternary interpolated version of the color at the specified coordinates on the plane.\n\nGlobal variables\n\nAll of these variables are populated by Karmana.__init__(), and can their values can be accessed by, for example, Karmana.state_df[] (note the empty square brackets, which indicate that you're accessing the value of the Ref).\n\nstate_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's states.\nhr_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's homogeneous regions, as defined by CMIE.\ndistrict_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's districts.\nindia_rivers::Ref{ArchGDAL.IGeometry}: An ArchGDAL.IGeometry which holds the intersection of the rivers of the world with the border of India.\n\nCPHS helper functions\n\nKarmana has several CPHS helper functions to parse data.\n\nCapex helper functions\n\nKarmana has some parsers for CMIE Capex data lat/long strings.\n\nSpatial utilities\n\nKarmana has some geodetic/spatial utilities, like annular_ring and line_to_geodetic_width_poly.  See the docs and examples for more information!\n\nEnvironment variables\n\nKarmana can be configured by the following environment variables:\n\nKARMANA_DISTRICT_SHAPEFILE which points to a shapefile which Karmana should use to populate the district, HR and state dataframes.  Note that there are a lot of assumptions made on the structure of the shapefile - look at the code of Karmana.__init__() to see what these are.\nKARMANA_APPLY_SHAPEFILE_PATCHES indicates whether to apply certain patches to the shapefile (\"true\") or not (\"false\").  Defaults to true.\nKARMANA_RIVER_SHAPEFILE indicates the path to some shapefile which contains a selection of rivers (usually as linestrings).  If not found, Karmana will download this data from UNESCO.\n\n\n\n\n\n","category":"module"},{"location":"autodocs/#Karmana.district_df","page":"Autodocs","title":"Karmana.district_df","text":"Contains the District dataframe\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#Karmana.hr_df","page":"Autodocs","title":"Karmana.hr_df","text":"Contains the HR dataframe\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#Karmana.india_rivers","page":"Autodocs","title":"Karmana.india_rivers","text":"Contains an ArchGDAL.IGeometry which contains a multilinestring of the intersection of the world's rivers with India.\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#Karmana.state_df","page":"Autodocs","title":"Karmana.state_df","text":"Contains the State dataframe\n\n\n\n\n\n","category":"constant"},{"location":"autodocs/#Karmana.TernaryColormap","page":"Autodocs","title":"Karmana.TernaryColormap","text":"struct TernaryColormap\nTernaryColormap(; xmap, ymap, zmap)\n\nRepresents a ternary colormap.  \n\nConstruct by passing three PlotUtils.ColorGradients or objects which can be converted to them (symbols, strings).\n\nCall by using the ternary colormap object (tmap) as a callable - methods include tmap(x, y, z) or tmap(Point3f(...)) or tmap((x, y, z)).  Returns an RGBAf object when called.\n\nVisualize by calling Makie.plot(tmap).\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#Karmana.__init__-Tuple{}","page":"Autodocs","title":"Karmana.__init__","text":"Karmana.__init__()\n\nInitializes the package by loading geometries.  This is only really relevant to the indiaoutline recipe.\n\nFirst, load the state, hr and district geometries of India from data.mayin.org, or the provided cache path. Then, compute the intersection between the world's rivers (provided by env variable) and India, or load from cache stored in scratchspace.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana._missing_in-Tuple{Any, Any}","page":"Autodocs","title":"Karmana._missing_in","text":"_missing_in(x, set)\n\nHandles the case where x is missing, which in  does not.  If x is missing and there is a missing value in set, then returns true.  If there is no missing value in set, returns false.  Otherwise, the behaviour is the same as Base.in.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana._prepare_merged_geom_dataframe-Tuple{DataFrames.DataFrame, Vararg{Symbol}}","page":"Autodocs","title":"Karmana._prepare_merged_geom_dataframe","text":"prepare_merged_geom_dataframe(df::DataFrame, hr_column_id::Symbol; capture_cols::Tuple{Symbol})\n\nPrepares a dataframe of merged geometries by grouping df by hr_column_id.   The values of each of the capture_cols in the first row of each group are also  included in the new dataframe, along with the value of  hr_column_id.   Each group in the input corresponds to a row in the output dataframe.\n\nThis method assumes that there is a geometry column in the DataFrame which contains objects which have a MultiPolygonTrait in GeoInterface.\n\nReturns a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana._set_plot_z-Tuple{Any, Real}","page":"Autodocs","title":"Karmana._set_plot_z","text":"_set_plot_z(plot, zlevel::Real)\n\nSets the plot's z-level to the provided argument, leaving the rest of the translation attributes  the same.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.annular_ring-Union{Tuple{T}, Tuple{F}, Tuple{F, Rasters.Raster{T, 2, D, R, A} where {D<:Tuple, R<:Tuple, A<:AbstractMatrix{T}}, Any, Any, Any, Any}} where {F, T}","page":"Autodocs","title":"Karmana.annular_ring","text":"annular_ring(f, source::Raster, lon, lat, outer_radius, inner_radius; pass_mask_size = false)\n\nReturns the result of applying f to the subset of source which is masked by the annular ring defined by lon, lat, outer_radius, inner_radius. The annular ring is constructed in geodetic space, i.e., distance is physically preserved.\n\nsource may be a 2D raster (in which case this function returns a value), or a 3D RasterStack or a RasterSeries of 2D rasters, in which case this function returns a Vector of values.\n\nArguments\n\nf is a function which takes a Raster and returns a value.  This is the function which will be applied to the subset of source which is masked by the constructed annular ring. The result of f is returned.\nsource is a Raster which will be masked by the annular ring.  This can be 2D, in which case annular_ring will return a single value, or 3D, in which case annular_ring will return a Vector of values.\nlon, lat are the coordinates of the centre of the annular ring, in degrees.\nouter_radius and inner_radius are the outer and inner radii of the annular ring, in metres.\npass_mask_size determines whether to pass a second argument to f containing the number of points in the mask.  This is useful if you are taking statistical measures.\n\nHow it works\n\nFirst, an annular ring polygon is created (in geodetic space, using get_geodetic_circle).\nNext, the extent of the annular ring polygon is computed, and the source raster is subsetted to that extent.  This is for efficiency, and so that the minimum possible number of multiplications are performed.\nThe annular ring polygon is rasterized, using Rasters.boolmask.\nThe subsetted source raster is multiplied by the rasterized annular ring polygon.\nFinally, f is applied to the result of the multiplication.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.create_page","page":"Autodocs","title":"Karmana.create_page","text":"create_page(paper_size, qr_code_link; landscape = automatic, naxes = 1, supertitle = \"Title\", description = \"...\", kwargs...)\n\nCreates a figure of the specified size with the specified arguments, themed for XKDR.  Applies the appropriate paper size theme (theme_a4, theme_a3, etc.)\n\nArguments\n\npaper_size: A symbol representing the desired paper size; can be :a[0/1/2/3/4].  More planned.  In the future, you may also be able to pass a tuple.\nqr_code_link: The contents of the QR code shown at the bottom left of the page.  Must be a string.\n\nKeyword arguments\n\nlandscape = automatic: Decides whether the figure should be in landscape or portrait mode.  If automatic, decides automatically.  To set this manually, set landscape = true or landscape = false.\nnaxes = 1: The number of axes to create in the central grid.  Automatically laid out.  \naxistitles = Makie.automatic: The titles for each axis.  If set to automatic, they will be the positions of the axes in the layout.\nhideaxisdecorations = true: Whether to hide the decorations (tick labels, tick marks, etc.) for each axis.\nhideaxisspines = true: Whether to hide the spines (frame lines) for each axis.\nsupertitle = \"Title\": The title of the figure, in the \"header\" gridlayout.\ndescription = \"Placeholder\": The description of the figure, in the \"footer\" gridlayout (page.description_layout[1, 1]).\npadding: The padding around the figure.  If a number, sets all sides to the same value.  If a tuple, sets the padding to (left, right, top, bottom).\naxisaspect = DataAspect(): Sets the aspect ratio of the axis.  You can set this to nothing if you want the default.\n\nReturns\n\nReturns a NamedTuple containing the following items:\n\nfigure: The Figure in which everything is plotted.\nsupertitle: The Label which serves as the figure's title.\naxis_layout: The GridLayout in which the axes are placed.\naxes: A Matrix{Union{Axis, Nothing}} which contains the axes which can be placed.  If nrows * ncols > naxes, then the remaining positions will be nothing.\ndescription_layout: The GridLayout in which the description is placed.  Has 3 columns and 1 row.  The description label is located in description_layout[1, 1], and [1, 3] is reserved for a box representing the QR code.  You can plot a legend or colorbar in description_layout[1, 2].\ndescription_label: The Label which holds the figure's description.\n\nThe items can be extracted from the named tuple using standard getproperty syntax, as in the following example:\n\npage = create_page(:a4, \"https://xkdr.org\")\npage.figure\npage.axes[i::Int, j::Int]\npage.description_layout\npage.description_label\n...\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#Karmana.do_geoquery-Tuple{Any, Any}","page":"Autodocs","title":"Karmana.do_geoquery","text":"do_geoquery(connection, layer; geometrycols = [\"SHAPE\"])::DataFrame\n\nPerforms a SELECT * FROM $layer operation on the database which connection points to, but all geometrycols are additionally wrapped in ST_AsBinary, which converts geometries from SQL format (which has an extra CRS indicator) to well known binary (WKB) format, which is parseable by e.g. ArchGDAL (or WellKnownGeometry.jl, which is substantially slower).\n\nWKB columns are given the suffix _wkb to differentiate them from the original columns.  \n\nResults are returned as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.get_HR_number-Tuple{String}","page":"Autodocs","title":"Karmana.get_HR_number","text":"get_HR_number(hr::Union{String, Missing})::Union{Int, Missing}\n\nExtracts the number from a string of a form \"HR ???\" and returns it. If the input is missing, then missing is returned.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.get_geodetic_circle-Tuple{Any, Any, Any}","page":"Autodocs","title":"Karmana.get_geodetic_circle","text":"get_geodetic_circle(lon, lat, radius; npoints = 100, geodesic = Proj.geod_geodesic(6378137, 1/298.257223563))\n\nReturns a Vector of Makie.Point2f which represent a circle of radius radius centered at lon, lat, computed in geodetic coordinates.\n\nlon and lat are in degrees, radius is in metres.\n\n!!! note Performance     Because this calls out to C, it's a bit slower than I'd like it to be, but not by much.  100 points takes about 28ms on my machine, a souped up Macbook Pro M1.\n\nMaking annular rings\n\nTo create an annular ring, it's sufficient to say:\n\nlon, lat = 72, 19\ninner_radius = 1000\nouter_radius = 10000\nannular_polygon = GeometryBasics.Polygon(\n        get_geodetic_circle(lon, lat, outer_radius), \n        [reverse(get_geodetic_circle(lon, lat, inner_radius))] # note the `reverse` here - this is for the intersection fill rule.\n)\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.get_sentiment_props-Tuple{Any, Any}","page":"Autodocs","title":"Karmana.get_sentiment_props","text":"get_sentiment_props(df, sentiment_key; good = \"Good times\", bad = \"Bad times\", uncertain = \"Uncertain times\")\n\nTakes in a DataFrame from the CPHS aspirational wave database, and returns a tuple of (bad_prop, good_prop, uncertain_prop).\n\nThe keys can be changed by keyword arguments; fundamentally, this is a helper function to extract proportions from a three-value system.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.indiaoutline!-Tuple","page":"Autodocs","title":"Karmana.indiaoutline!","text":"indiaoutline!(admin_level::Symbol, ids::Vector, vals::Vector{<: Real}; kw_args...)\nindiaoutline!(admin_level::Symbol, dataframe::DataFrame, [id_column::Symbol], value_column::Symbol; kw_args...)\n\nPlots an outline of India, merged with the data passed in.  This data must fundamentally have two things: a column of IDs, and a column of values.  The IDs must match the IDs in the CPHS database,  and the values may be either numbers, or explicit colors.\n\nArguments\n\nadmin_level must be one of :State, :HR, or :District.  \n\nids must be a Vector{Union{Int, Missing}} or a Vector{Int}.  It and vals must have the same length.\n\nAttributes\n\nOne can set the attributes of the various plot elements by setting the values of the corresponding nested Attributes.  These are plot.State, plot.HR, plot.District, and plot.River.\n\nFor example, to set the stroke width of districts to 0.25, one would do:\n\nplot.District.strokewidth[] = 0.25\n\nThe attributes available for State, HR, and District are those of poly; the attributes available for River are those of lines.\n\nCropping the map to provided data\n\nIf the attribute crop_to_data is true, then this crops the map to the bounding box of the provided IDs only, and does not draw any other states/HRs/districts. Otherwise, all available geometries are drawn, but only the provided IDs are colored by their values; the rest of the geometries remain transparent.\n\nControlling how the data is merged\n\nYou can control the column on which data is merged by setting the merge_column and external_merge_column keyword arguments.\n\nmerge_column specifies the key with which to merge of the provided ids to the CPHS database for that admin level.\nexternal_merge_column specifies the key with which to merge the provided ids with the lower admin level geometries.  \n\nFor example, if the provided admin_level is :State, then merge_column will control the key for state_df, and external_merge_column will control the key for hr_df and district_df.\n\nTo see all available attributes and their defaults, have a look at the extended help section by running ??indiaoutline! in the REPL.\n\nExtended help\n\nAvailable attributes, and their values\n\nAvailable attributes and their defaults for Combined{Karmana.indiaoutline!} are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.indiaoutline-Tuple","page":"Autodocs","title":"Karmana.indiaoutline","text":"indiaoutline!(admin_level::Symbol, ids::Vector, vals::Vector{<: Real}; kw_args...)\nindiaoutline!(admin_level::Symbol, dataframe::DataFrame, [id_column::Symbol], value_column::Symbol; kw_args...)\n\nPlots an outline of India, merged with the data passed in.  This data must fundamentally have two things: a column of IDs, and a column of values.  The IDs must match the IDs in the CPHS database,  and the values may be either numbers, or explicit colors.\n\nArguments\n\nadmin_level must be one of :State, :HR, or :District.  \n\nids must be a Vector{Union{Int, Missing}} or a Vector{Int}.  It and vals must have the same length.\n\nAttributes\n\nOne can set the attributes of the various plot elements by setting the values of the corresponding nested Attributes.  These are plot.State, plot.HR, plot.District, and plot.River.\n\nFor example, to set the stroke width of districts to 0.25, one would do:\n\nplot.District.strokewidth[] = 0.25\n\nThe attributes available for State, HR, and District are those of poly; the attributes available for River are those of lines.\n\nCropping the map to provided data\n\nIf the attribute crop_to_data is true, then this crops the map to the bounding box of the provided IDs only, and does not draw any other states/HRs/districts. Otherwise, all available geometries are drawn, but only the provided IDs are colored by their values; the rest of the geometries remain transparent.\n\nControlling how the data is merged\n\nYou can control the column on which data is merged by setting the merge_column and external_merge_column keyword arguments.\n\nmerge_column specifies the key with which to merge of the provided ids to the CPHS database for that admin level.\nexternal_merge_column specifies the key with which to merge the provided ids with the lower admin level geometries.  \n\nFor example, if the provided admin_level is :State, then merge_column will control the key for state_df, and external_merge_column will control the key for hr_df and district_df.\n\nTo see all available attributes and their defaults, have a look at the extended help section by running ??indiaoutline! in the REPL.\n\nExtended help\n\nAvailable attributes, and their values\n\nAvailable attributes and their defaults for Combined{Karmana.indiaoutline} are: \n\n  District               Attributes with 7 entries:\n  label => Districts\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGB{N0f8}(0.549,0.549,0.549)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 98\n  HR                     Attributes with 7 entries:\n  label => HR regions\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGBA{Float32}(0.901961,0.623529,0.0,1.0)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 99\n  Legend                 Attributes with 2 entries:\n  draw => true\n  polypoints => 1\n  River                  Attributes with 5 entries:\n  color => RGB{N0f8}(0.678,0.847,0.902)\n  label => Rivers\n  linewidth => 0.2\n  visible => true\n  zlevel => 97\n  State                  Attributes with 7 entries:\n  label => States\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGB{N0f8}(0.0,0.0,0.0)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 101\n  colormap               :viridis\n  colorrange             MakieCore.Automatic()\n  crop_to_data           false\n  external_merge_column  MakieCore.Automatic()\n  highclip               \"nothing\"\n  lowclip                \"nothing\"\n  merge_column           MakieCore.Automatic()\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.latlong_string_to_points-Tuple{AbstractString}","page":"Autodocs","title":"Karmana.latlong_string_to_points","text":"latlong_string_to_points(latlong_string)\n\nParses a string of the form lat1,long1 : lat2,long2 : lat3,long3 : ...  and returns a Vector of Point2e which define points as (long, lat).  \n\nIs robust to cutoff errors and other potential issues.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.line_to_geodetic_width_poly-Tuple{Vector{<:Point2}, Any}","page":"Autodocs","title":"Karmana.line_to_geodetic_width_poly","text":"line_to_geodetic_width_poly(line::Vector{<: Point2}, width; geodesic = Proj.geod_geodesic(6378137, 1/298.257223563))\n\nReturns a Vector{Point2{Float64}} which represents a polygon which is width metres wide, and follows the path of line.\n\nThis is mostly useful for tracing wide lines on Raster maps.\n\nFundamentally, you can think of this function as creating a polygon from a line, with a specified width.  There's no interpolation, though -  if you want interpolation, pass an interpolated vector of points in.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.maps_db_connection","page":"Autodocs","title":"Karmana.maps_db_connection","text":"maps_db_connection(user = ENV[\"MAPS_USER\"], password = ENV[\"MAPS_PASSWORD\"])::DBInterface.Connection\n\nReturns a connection to the maps database on data.mayin.org, which must be closed by DBInterface.close!.\n\n\n\n\n\n","category":"function"},{"location":"autodocs/#Karmana.merge_polys-Tuple{AbstractVector}","page":"Autodocs","title":"Karmana.merge_polys","text":"merge_polys(polys::AbstractVector{<: Union{Polygon, MultiPolygon}})\n\nMerges a vector of polygons into a single MultiPolygon using ArchGDAL.union.\n\nReturns an ArchGDAL geometry.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.nearest_paper_size-Tuple{Real, Real}","page":"Autodocs","title":"Karmana.nearest_paper_size","text":"nearest_paper_size(width::Real, height::Real)::Symbol\n\nReturns the closest paper size to the provided size, which must be a 2-tuple.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.points_weights-Tuple{Any, Any}","page":"Autodocs","title":"Karmana.points_weights","text":"points_weights(latlong_strings::Vector{:< AbstractString}, costs::Vector{<: Real})\n\nParses strings of the form lat1,long1 : lat2,long2 : lat3,long3 : ...  and returns a Vector of Point2e which define points as (long, lat), as well as a vector of weights per point.  If the string has more than one point defined,  the weight is spread across all n points such that each point has a weight of cost[i]/n.\n\nReturns (::Vector{Point2e}, ::Vector{<: Real}).\n\nnote: Note\nThis format of data is often found in CMIE capex location data.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.prepare_merged_river_geom-Tuple{Any, Any}","page":"Autodocs","title":"Karmana.prepare_merged_river_geom","text":"prepare_merged_river_geom(shapefile_path, mask_poly)\n\nUses ArchGDAL to prepare a multilinestring which shows river paths within India.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.prepare_page-Tuple{Union{Symbol, Tuple{var\"#s100\", var\"#s100\"} where var\"#s100\"<:Real}, String}","page":"Autodocs","title":"Karmana.prepare_page","text":"prepare_page(\n    paper_size::Union{Symbol, NTuple{2, <: Real}},\n    qr_code_contents::String;\n    landscape = false,\n    padding = 3,\n    logo = rotr90(FileIO.load(assetpath(\"logos\", \"XKDR_Logomark_RGB_White.jpg\"))),\n    logo_height = 40,\n    logo_padding = 5,\n    qr_code_height = 60,\n    qr_code_padding = 10,\n)\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.rgb_to_cmyk_pdf-Tuple{AbstractString, AbstractString}","page":"Autodocs","title":"Karmana.rgb_to_cmyk_pdf","text":"rgb_to_cmyk_pdf(source_file::AbstractString, dest_file::AbstractString)\n\nRuns Ghostscript on source_file to convert its color schema from RGB to CMYK, and stores the result in dest_file.\n\nThis works well when preparing a PDF for printing, since many printer drivers don't perform the conversion as well as Ghostscript does.  You might see a  green tint on black when printing in color; this ameliorates that to a large degree.\n\nnote: Note\nConverting from RGB to CMYK is a lossy operation, since CMYK is a strict subset of RGB.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.searchsortednearest-Tuple{Any, Any}","page":"Autodocs","title":"Karmana.searchsortednearest","text":"searchsortednearest(a, x)\n\nReturns the index of the nearest element to x in a. a must be a sorted array, and its elements must be mathematically interoperable with x.  \n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.shape_wkb_to_module_geom!-Tuple{Module, DataFrames.DataFrame}","page":"Autodocs","title":"Karmana.shape_wkb_to_module_geom!","text":"shape_wkb_to_module_geom!(mod::Module, table::DataFrame; new_colname = :geometry, wkb_colname = :SHAPE_wkb)\n\nConverts the geometries in old_colname (in WKB format as eltype(old_colanme) = Vector{UInt8}) into geometries of the  provided module mod.  This goes through ArchGDAL instead of being pure-Julia with WellKnownGeometry, since that's faster.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.state_hr_district_dfs-Tuple{}","page":"Autodocs","title":"Karmana.state_hr_district_dfs","text":"state_hr_district_dfs()\n\nA wrapper function which materializes the state, HR, and district dataframes in Julia, by connecting to the maps database of data.mayin.org.  \n\nReturns 3 DataFrames (state_table, hr_table, district_table) which all have columns :geometry populated by GeometryBasics geometry, which is suitable for plotting.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Karmana.target_point-NTuple{4, Any}","page":"Autodocs","title":"Karmana.target_point","text":"target_point(lon, lat, azimuth, arclength; geodesic = Proj.geod_geodesic(6378137, 1/298.257223563))\n\nReturns a Makie.Point2f which represents the point at arclength metres from lon, lat in the direction of azimuth. Basically a thin wrapper around Proj's GeographicLib geod_directline.\n\njldoctest julia> target_point(0, 0, 0, 0) 2-element Point2{Float64} with indices SOneTo(2):  0.0  0.0`\n\n\n\n\n\n","category":"method"},{"location":"cphs/#CPHS-utilities","page":"CPHS","title":"CPHS utilities","text":"","category":"section"},{"location":"cphs/","page":"CPHS","title":"CPHS","text":"get_HR_number\nget_sentiment_props","category":"page"},{"location":"cphs/#Karmana.get_HR_number","page":"CPHS","title":"Karmana.get_HR_number","text":"get_HR_number(hr::Union{String, Missing})::Union{Int, Missing}\n\nExtracts the number from a string of a form \"HR ???\" and returns it. If the input is missing, then missing is returned.\n\n\n\n\n\n","category":"function"},{"location":"cphs/#Karmana.get_sentiment_props","page":"CPHS","title":"Karmana.get_sentiment_props","text":"get_sentiment_props(df, sentiment_key; good = \"Good times\", bad = \"Bad times\", uncertain = \"Uncertain times\")\n\nTakes in a DataFrame from the CPHS aspirational wave database, and returns a tuple of (bad_prop, good_prop, uncertain_prop).\n\nThe keys can be changed by keyword arguments; fundamentally, this is a helper function to extract proportions from a three-value system.\n\n\n\n\n\n","category":"function"},{"location":"financial/#Financial-utilities","page":"Financial utilities","title":"Financial utilities","text":"","category":"section"},{"location":"financial/","page":"Financial utilities","title":"Financial utilities","text":"Nothing here, but planned ","category":"page"},{"location":"financial/#Nominal-to-real-value","page":"Financial utilities","title":"Nominal to real value","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"EditURL = \"https://github.com/xKDR/Karmana.jl/blob/main/examples/poster.jl\"","category":"page"},{"location":"examples/poster/#Creating-a-poster-using-Karmana","page":"Creating a poster","title":"Creating a poster using Karmana","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"using Karmana, Rasters, CairoMakie, GeoInterface","category":"page"},{"location":"examples/poster/#Getting-the-data","page":"Creating a poster","title":"Getting the data","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"We'll get some real-world data to plot, since this isn't as interesting otherwise.","category":"page"},{"location":"examples/poster/#Raster-data","page":"Creating a poster","title":"Raster data","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Let's get some raster data to plot, in this case the precipitation data from the WorldClim project.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"worldclim_bioclim_raster = Raster(WorldClim{BioClim}, :BIO13)","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This looks like:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"f, a, p = heatmap(worldclim_bioclim_raster; axis = (; aspect = DataAspect()))\na.title = \"Precipitation in wettest month\"\ncb = Colorbar(f[1, 2], p; label = \"Precip. (mm)\")\nf","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"That doesn't tell us much - everything is blue! Let's increase the contrast, by setting a different color range:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"crange = Makie.PlotUtils.zscale(p[3][], 5000; contrast = 0.1)","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This is a pretty useful function which you can use when your dataset has a lot of outliers!","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"p.colorrange[] = crange\nf","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Now that makes a lot more sense. We can see how areas in South America, East Africa, and South and Southeast Asia are all pretty rainy.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"To plot the heatmap, we'll want to crop the BioClim raster to the extent of India. Here's how we can do that:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"india_border = Karmana.merge_polys(Karmana.state_df[].geometry)\nmasked_india_raster = Rasters.mask(worldclim_bioclim_raster[:, :, 1], with = india_border)[GeoInterface.extent(india_border)]\nheatmap(masked_india_raster; colorrange = crange, axis = (; aspect = DataAspect()))","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Note how the raster is now cropped to the extent of India.","category":"page"},{"location":"examples/poster/#State-level-data","page":"Creating a poster","title":"State-level data","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Since this is not running with access to CPHS...we'll just make something up!","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"fake_population = rand(size(Karmana.state_df[], 1))\nstate_ids = Karmana.state_df[].st_cen_cd","category":"page"},{"location":"examples/poster/#Creating-the-poster","page":"Creating a poster","title":"Creating the poster","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"We start by creating a page; we want this poster to be a3 sized and have 2 axes.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"page = create_page(\n    :a3,\n    \"https://xkdr.github.io/Karmana.jl/dev\", # the QR code,\n    naxes = 2,\n    landscape = true\n)\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"While you can provide the title and the description as keywords to create_page, we'll instead set them manually, to show how it can be done.","category":"page"},{"location":"examples/poster/#Plotting-to-the-figure","page":"Creating a poster","title":"Plotting to the figure","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"But first, let's plot!","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"precipitation_plot = heatmap!(page.axes[1, 1], masked_india_raster; colorrange = crange)\nindia_outline_plot = indiaoutline!(page.axes[1, 2], :State, state_ids, fake_population; colormap = :Oranges)\n\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"The poster is optimized for printing, so there's a lot of whitespace (1 inch) at the border.","category":"page"},{"location":"examples/poster/#Configuring-figure-attributes","page":"Creating a poster","title":"Configuring figure attributes","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"In many other plotting packages, if you want to configure a figure, you have to do it at the time you create it. This is not the case in Makie - you can configure the figure's attributes at any time.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This means we don't have to worry about the initial settings too much, and we can configure the figure as we go.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Let's configure the title now!  The title is a Label object, which we can access through page.supertitle:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"page.supertitle","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"From there, it's a standard label, so we can set its attributes:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"page.supertitle.text = \"Does precipitation impact population?\"\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"The description is also a label, accessible via page.description_label:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"page.description_label.text = \"This answers all of your burning questions - by raining on them!\"\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"The description label is in the bottom row, which contains a layout called page.description_layout:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"page.description_layout","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Finally, we can change the titles of the axes, and similarly any other axis attribute:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"page.axes[1, 1].title = \"Precipitation\"\npage.axes[1, 2].title = \"Population (fake)\"\npage.figure","category":"page"},{"location":"examples/poster/#Creating-a-colorbar","page":"Creating a poster","title":"Creating a colorbar","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Let's also add a colorbar, to represent the color scale of the precipitation plot:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"cb = Colorbar(page.description_layout[1, 2], precipitation_plot; label = \"Precip. (mm)\", flipaxis = true, tickalign = 1)\npage.figure\n\npage.description_label.alignmode[] = Outside()\n\npage.figure","category":"page"},{"location":"examples/poster/#Creating-a-legend","page":"Creating a poster","title":"Creating a legend","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"We can also add a legend, to represent the colors of the states. We'll place this in the right side of the layout cell which currently holds the colorbar.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"To create this legend, we'll use PolyElements to represent discrete colors.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"leg = Legend(\n    page.description_layout[1, 2, Right()], # this is placed as a protrusion in cell `[1, 2]`.\n    [ # elements\n        PolyElement(; color) for color in cgrad(:Oranges)[0.125:0.25:1]\n    ],\n    [ # labels\n        \"0-25%\",\n        \"25-50%\",\n        \"50-75%\",\n        \"75-100%\",\n    ],\n    \"Population\"; # title\n    orientation = :vertical,\n    nbanks = 1,\n    labelsize = 10,\n    framevisible = false,\n)","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This legend is protruding a bit, let's change how it's aligned vertically:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"leg.valign = :bottom\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This made the legend have its bottom point aligned to the row's bottom.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"The bottom of the legend is still a little above the colorbar, though - but we can fix that, by changing the padding of the legend:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"leg.padding","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This is in a (left, right, bottom, top) format, so","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"leg.padding[] = (leg.padding[][1], leg.padding[][2], 0f0, leg.padding[][4])\npage.figure","category":"page"},{"location":"examples/poster/#Moving-things-around-in-the-layout","page":"Creating a poster","title":"Moving things around in the layout","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"You can move objects around the layout very easily.  Let's swap the colorbar with the description:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"page.description_layout[1, 1] = cb\npage.description_layout[1, 2] = page.description_label\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This is a pretty cool thing, but the figure needs some tuning.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"colsize!(page.description_layout, 2, Auto())\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Let's also spread the elements out evenly.  The way to do this is to add another column to the description_layout:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"page.description_layout[1, 4] = contents(page.description_layout[1, 3])[1]\npage.description_layout[1, 3] = leg\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Let's also align the description to the bottom of the page,","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"page.description_label.valign[] = :bottom\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This isn't the most elegant solution, but you can have a colorbar label on the opposite side to the ticks.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"We can do this by putting the colorbar into a new gridlayout, and the label below that:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"colorbar_layout = GridLayout(page.description_layout[1, 1])\ncolorbar_layout[1, 1] = cb\ncb.label = \"\"\ncb_label = Label(colorbar_layout[2, 1], \"Precip. (mm)\", font = :bold)\npage.figure","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Oops!  The label has squashed our colorbar.  Let's fix that, and decrease the spacing:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"cb_label.tellwidth = false\ncb_label.tellheight = true\nrowgap!(colorbar_layout, 1, 10)\npage.figure","category":"page"},{"location":"examples/poster/#Saving-posters","page":"Creating a poster","title":"Saving posters","text":"","category":"section"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Generally, you will get the best output if you save your poster as a PDF, since text etc. will be vectorized.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"You can do this by:","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"save(\"poster.pdf\", page.figure; pt_per_unit = 1)","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"Here, the pt_per_unit argument enforces that the paper size must be equal to the figure's resolution.  If it is not, then 1 pt is treated as equivalent to 0.75 px, which is the default scaling for the web.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"That being said, large images and complex polygons with lots of points can cause the file size to increase quite a bit, up to twenty megabytes for only one IndiaOutline plot.","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"In order to reduce the file size, you can rasterize the plot (this only works with the CairoMakie backend).","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This is done by setting the rasterize attribute of the plot to some number, which controls the pixel density.  If the rasterized plot has a pixel size of (n, n), then with plot.rasterize = i, the rasterized image which \"replaces\" the plot in the final PDF will have a resolution of (n*i, n*i).","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"india_outline_plot.rasterize = 3","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"save(\"poster.pdf\", page.figure; pt_per_unit = 1)","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This reduces the file size to about 1 MB.  You can set this to any stereotypical","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"","category":"page"},{"location":"examples/poster/","page":"Creating a poster","title":"Creating a poster","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"EditURL = \"https://github.com/xKDR/Karmana.jl/blob/main/examples/annular_ring.jl\"","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"Annular rings with Rasters.jl","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"This tutorial is not meant to show a true usecase, rather to show what you can do with the annular_ring function and a couple other nice tools.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"using Rasters, Dates\nusing Karmana # provides `annular_ring` and friends\nusing CairoMakie","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"Let's get some interesting data, you could put nightlights here as well.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"Since we have to download the data on the CI server, I'll restrict this analysis to Delhi.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"delhi_lonlat = Point2f(77.1025, 28.7041) # from Wikipedia","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"This should either be a 2D or 3D raster.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"# nightlights_raster = view(Raster(\"/Users/anshul/Documents/Business/India/XKDR/code/maps/DATA/updated_india.nc\"; lazy = true), :, :, 1, :)","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"This is the MODIS 250m vegetation dataset, we're getting all of the measurements from the year 2022.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"We have to do some processing here, since we want a true 3D raster, and not a 4D raster with a singleton 3rd dimension.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"First, download the raster as a RasterSeries.  This is basically a collection of rasters which is correctly hooked up with time indices, etc.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"This line downloads the data in a 50x50km box around Delhi, for all readings in 2022.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"modis_series = RasterSeries(MODIS{MOD13Q1}, :NDVI; lat = delhi_lonlat[2], lon = delhi_lonlat[1], km_ab = 50, km_lr = 50, date = (Date(2022,1,1), Date(2022,12,1)))","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"Let's see what one of these rasters looks like:","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"modis_series[1]","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"Oops, this is a 3D raster!  We can fix that real quick:","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"modis_2d_series = RasterSeries(view.(modis_series, :, :, 1), dims(modis_series)...)","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"We can actually concatenate these into a single raster, which we'll do here:","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"modis_raster = cat(modis_2d_series..., dims = dims(modis_2d_series)[1])","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"We now have a proper 3D raster!  Let's do a quick animation to see how it looks:","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"fig, ax, hm = heatmap(modis_raster[:, :, 1], colorrange = (0, Makie.PlotUtils.zscale(modis_raster)[end]), axis = (; aspect = DataAspect()))\ncb = Colorbar(fig[1, 2], hm; label = \"Vegetation index\")\nfig","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"We can interpolate the RasterSeries for a smoother animation:","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"using DataInterpolations: QuadraticInterpolation\nmodis_interpolated = QuadraticInterpolation(modis_2d_series, Dates.value.(collect(dims(modis_2d_series)[1])))\nmodis_interpolated(Dates.value(Date(2022, 5, 1)))","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"Let's make a video of this:","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"fig, ax, hm = heatmap(modis_interpolated(1.0), colorrange = (0, Makie.PlotUtils.zscale(modis_raster)[end]), axis = (; aspect = DataAspect()))\ncb = Colorbar(fig[1, 2], hm; label = \"Vegetation index\")\nrecord(fig, \"modis_vegetation_over_delhi.mp4\", Date(2022, 1, 1):Day(1):Date(2022, 12, 31); framerate = 30) do date\n    hm[3][] = Makie.convert_arguments(Makie.ContinuousSurface(), modis_interpolated(Dates.value(date)))[3]\n    ax.title = string(date)\nend","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"(Image: )","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"Now, for the annular ring!","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"We can easily get the vegetation data over Delhi for a ring between 4 and 15 km from the center:","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"vegetation_series = Karmana.annular_ring(modis_raster, delhi_lonlat..., 15000, 4000; pass_mask_size = true) do raster, mask_size\n    # We can do some processing here, if we want to.\n    # For now, we just take the mean of all points in the mask.\n    sum(raster) / mask_size\nend","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"You should check out the documentation for the annular_ring function!","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"Here, what happens is that each \"slice\" in time of modis_raster is multiplied by an annular-ring \"mask\" of the same dimensions.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"That mask is 1 (true) on the pixels which the ring lies on, and 0 (false) elsewhere.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"mask_size is simply the sum of this mask, which is the number of pixels within the mask. This is practically required for any meaningful data processing. If we naively took the mean, it would be lower than the mean of the cells within the mask, since all the cells outside the mask are zero, but still included in the mean.","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"This is what the timeseries looks like!","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"f, a, p = lines(\n    Dates.value.(collect(dims(modis_2d_series)[1])) .- Dates.value(Date(2022, 1, 1)), # Makie doesn't support Date axes yet, this is the best we can do.\n    vegetation_series;\n    axis = (\n        title = \"Vegetation over time in Delhi\",\n        ylabel = \"Mean vegetation index\",\n        xlabel = \"Month\",\n        xticks = (collect(Dates.value.((Date(1):Month(1):Date(2))[1:12])), Dates.monthname.(1:12)), # more hacks for a \"month axis\"\n        xticklabelrotation = π/4,\n    ),\n    label = \"2022\"\n)","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"For an encore, let's animate what the annular_ring function actually does to the raster:","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"fig, ax, hm = heatmap(modis_2d_series[1]; colorrange = (0, Makie.PlotUtils.zscale(modis_raster)[end]), axis = (; aspect = DataAspect()))\ncb = Colorbar(fig[1, 2], hm)\nrecord(fig, \"modis_annular_rings.mp4\", Date(2022, 1, 1):Day(1):Date(2022, 12, 31); framerate = 30) do date\n    ax.title[] = string(date)\n    Karmana.annular_ring(modis_interpolated(Dates.value(date)), delhi_lonlat..., 15000, 4000; pass_mask_size = false) do raster\n        # Here, we don't actually do any processing, just visualize the premultiplied raster!\n        hm[3][] = Makie.convert_arguments(Makie.ContinuousSurface(), raster)[3]\n    end\nend","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"(Image: )","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"","category":"page"},{"location":"examples/annular_ring/","page":"Annular rings on Rasters","title":"Annular rings on Rasters","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"EditURL = \"https://github.com/xKDR/Karmana.jl/blob/main/examples/demo.jl\"","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Basic demo","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, we'll load the packages.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"using Karmana\nusing Makie, CairoMakie # backend for Makie.jl - necessary if you want to save a plot\nusing Makie.Colors","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Before you run this code, make sure that you have read the Makie tutorial at docs.makie.org first!","category":"page"},{"location":"examples/demo/#Creating-a-page","page":"Basic Usage","title":"Creating a page","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, create a page of the appropriate size with xKDR poster formatting using the create_page function.  This returns a NamedTuple with a figure, some axes, and a customized layout. You must provide the page size you want to the function, as a Symbol (:a4-:a0 are supported for now).","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a4)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page is a NamedTuple with several elements, you can see the description of each in the documentation for create_page.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"To access the actual figure object, use page.figure.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page.figure","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"By default, the create_page function creates only one axis.  It returns all axes as a matrix, so that it's easy and intuitive to refer to them in a grid.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page.axes","category":"page"},{"location":"examples/demo/#Plotting-using-indiaoutline!","page":"Basic Usage","title":"Plotting using indiaoutline!","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"The IndiaOutline plot type was designed specifically for CPHS state, HR, or district level data, and automates a lot of the data munging you may have to do otherwise. You can call it in one of the following ways:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Provide an admin level Symbol, a vector of IDs for that admin level, and a vector of values for those IDs\nProvide a DataFrame, its ID column as a symbol, and its value column as a symbol\nProvide an","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"What we're doing below is the first option, which is also the most versatile. We're accessing","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"outline_plt = indiaoutline!(\n    page.axes[1, 1],\n    :HR,                      # admin level symbol\n    [70, 71, 72, 73, 74, 75], # IDs\n    rand(6);                  # values\n    HR = (strokecolor = to_color(:blue),),\n    colormap = :Reds\n)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Now, we display the page again (assuming you're using CairoMakie, graphs do not update interactively)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page.figure","category":"page"},{"location":"examples/demo/#Dynamically-updating-attributes","page":"Basic Usage","title":"Dynamically updating attributes","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"You can alter the attributes of an IndiaOutline plot after the fact, using the standard Makie attribute updating syntax. For example, you can change the colormap like this:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"outline_plt.plots[2].colormap[] = :Oranges\n\npage.figure","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"You can also change the attributes of the IndiaOutline plot itself, like this: (note the nested attributes here, if you want to know more, read the docstring).","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"outline_plt.State.strokewidth[]    = 0.2 #* 2 * 2\noutline_plt.HR.strokewidth[]       = 0.2 #* 2 * 2\noutline_plt.HR.strokecolor[]       = to_color(:blue)\noutline_plt.District.strokewidth[] = 0.1\n\npage.figure","category":"page"},{"location":"examples/demo/#Adding-a-colorbar","page":"Basic Usage","title":"Adding a colorbar","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"There's also a description, and you might note the space between that and the QR code, which is another layout cell which you can use for a legend, or a colorbar.  Here's how you can add a colorbar there (note that it should be horizontal):","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"cb = Colorbar(\n    page.description_layout[1, 2], # this is the empty layout cell into which you can place a colorbar``\n    outline_plt.plots[2].plots[1]; # this is the plot - TODO make this easier\n    flipaxis = false,              # this keeps the colorbar's axis at the bottom\n    vertical = false               # this sets the colorbar's orientation to be horizontal\n)\n\npage.figure","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"this is how to save a page object, if you want to save(\"my_map.png\", page.figure; px_per_unit = 3) save(\"my_map.pdf\", page.figure; pt_per_unit = 1)","category":"page"},{"location":"examples/demo/#Using-create_page","page":"Basic Usage","title":"Using create_page","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Multiple axes default to landscape, but that specific behaviour can be changed on the basis of paper size.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a4; landscape = true)\npage.figure","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"You can define a set number of axes, and they will be arranged in a grid.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a4; naxes = 2)\npage.figure","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Alternatively, you can also define the number of rows and columns.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a4; naxes = (2, 3))\npage.figure","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"There are multiple options for paper size, ranging from a4 to a0.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a3)\npage.figure","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"You can set any axis attribute like so:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a3; landscape = false, naxes = 4)\nsetproperty!.(page.axes, :aspect, (DataAspect(),))\npage.figure","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Here's what the page looks like with India plotted on each axis!","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"indiaoutline!.(page.axes, (:State,), (:all,))\npage.figure","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"The function is integrated well with Makie's themes, and we could make our own for e.g. BQ or BS, following their style.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Any plots on this new page follow the theme with which it was created.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = with_theme(theme_black()) do\n    create_page(:a3)\nend\npage.figure","category":"page"},{"location":"examples/demo/#Handling-raster-data","page":"Basic Usage","title":"Handling raster data","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Most raster data in Julia is handled by the Raster type from the Rasters.jl package. Makie.jl supports plotting Rasters efficiently using the heatmap function; however, if you want to display your data in 3D, you can also use surface!.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, we load Rasters (and GeoInterface, which is a common interface for vector data):","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"using Rasters, GeoInterface","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, we extract India's bounding box (I could have hardcoded this, but was too lazy).","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"This code merges all of the state geometries of India (including union territories) and finds their bounding box.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"india_bbox = GeoInterface.extent(Karmana.merge_polys(Karmana.state_df[].geometry))","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Now, we create a raster with 30x30 pixels, and fill it with a field of a known function.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, we create the field:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"field = Makie.peaks(30) # this is essentially a convenience function which generates a matrix of data","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Then, we can create the raster, using Rasters.X and Rasters.Y to indicate dimensions.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"mydims = (X(LinRange(india_bbox.X..., 30)), Y(LinRange(india_bbox.Y..., 30)))\nindia_raster = Raster(field, mydims)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"This is the raster.  We can plot it using heatmap, surface, or even contour! Any Makie plot type which is SurfaceLike() will work.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, let's make sure that the raster looks the same as the original data:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"fig, ax1, plt1 = surface(field; axis = (title = \"Original data\", type = Axis3))\nax2, plt2 = surface(fig[1, 2], india_raster; axis = (title = \"Raster\", type = Axis3))\nfig","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Hey, these look practically identical - except for the x and y values on the left plot, which are actually the bounding box for India!","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Now, let's plot the raster using heatmap:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"fig, ax, plt = heatmap(india_raster; axis = (title = \"Heatmap\", aspect = DataAspect()))","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Note the inclusion of aspect = DataAspect() in that heatmap call - this ensures that the pixels of the map reflect physical reality.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"indiaoutline!(ax, :State, :all; merge_column = :st_nm, external_merge_column = :st_nm)\nfig","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"This is clearly unrealistic, but otherwise correct!","category":"page"},{"location":"examples/demo/#TODOs","page":"Basic Usage","title":"TODOs","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Change the raster example here to plot data from BioClim","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"This page was generated using Literate.jl.","category":"page"},{"location":"capex/#CMIE-CapEx-utilities","page":"CapEx","title":"CMIE CapEx utilities","text":"","category":"section"},{"location":"capex/#Data-munging","page":"CapEx","title":"Data munging","text":"","category":"section"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"Apply these functions to columns from the CapEx database.","category":"page"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"latlong_string_to_points\npoints_weights","category":"page"},{"location":"capex/#Karmana.latlong_string_to_points","page":"CapEx","title":"Karmana.latlong_string_to_points","text":"latlong_string_to_points(latlong_string)\n\nParses a string of the form lat1,long1 : lat2,long2 : lat3,long3 : ...  and returns a Vector of Point2e which define points as (long, lat).  \n\nIs robust to cutoff errors and other potential issues.\n\n\n\n\n\n","category":"function"},{"location":"capex/#Karmana.points_weights","page":"CapEx","title":"Karmana.points_weights","text":"points_weights(latlong_strings::Vector{:< AbstractString}, costs::Vector{<: Real})\n\nParses strings of the form lat1,long1 : lat2,long2 : lat3,long3 : ...  and returns a Vector of Point2e which define points as (long, lat), as well as a vector of weights per point.  If the string has more than one point defined,  the weight is spread across all n points such that each point has a weight of cost[i]/n.\n\nReturns (::Vector{Point2e}, ::Vector{<: Real}).\n\nnote: Note\nThis format of data is often found in CMIE capex location data.\n\n\n\n\n\n","category":"function"},{"location":"capex/#Geographic-utilities","page":"CapEx","title":"Geographic utilities","text":"","category":"section"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"We also have geographic utilities, which use e.g. Rasters.  ","category":"page"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"note: Note\nMaybe this section should be its own page, since the functionality is pretty orthogonal?","category":"page"},{"location":"capex/#Annular-rings","page":"CapEx","title":"Annular rings","text":"","category":"section"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"annular_ring","category":"page"},{"location":"capex/#Karmana.annular_ring","page":"CapEx","title":"Karmana.annular_ring","text":"annular_ring(f, source::Raster, lon, lat, outer_radius, inner_radius; pass_mask_size = false)\n\nReturns the result of applying f to the subset of source which is masked by the annular ring defined by lon, lat, outer_radius, inner_radius. The annular ring is constructed in geodetic space, i.e., distance is physically preserved.\n\nsource may be a 2D raster (in which case this function returns a value), or a 3D RasterStack or a RasterSeries of 2D rasters, in which case this function returns a Vector of values.\n\nArguments\n\nf is a function which takes a Raster and returns a value.  This is the function which will be applied to the subset of source which is masked by the constructed annular ring. The result of f is returned.\nsource is a Raster which will be masked by the annular ring.  This can be 2D, in which case annular_ring will return a single value, or 3D, in which case annular_ring will return a Vector of values.\nlon, lat are the coordinates of the centre of the annular ring, in degrees.\nouter_radius and inner_radius are the outer and inner radii of the annular ring, in metres.\npass_mask_size determines whether to pass a second argument to f containing the number of points in the mask.  This is useful if you are taking statistical measures.\n\nHow it works\n\nFirst, an annular ring polygon is created (in geodetic space, using get_geodetic_circle).\nNext, the extent of the annular ring polygon is computed, and the source raster is subsetted to that extent.  This is for efficiency, and so that the minimum possible number of multiplications are performed.\nThe annular ring polygon is rasterized, using Rasters.boolmask.\nThe subsetted source raster is multiplied by the rasterized annular ring polygon.\nFinally, f is applied to the result of the multiplication.\n\n\n\n\n\n","category":"function"},{"location":"capex/#Geodetically-widened-lines","page":"CapEx","title":"Geodetically widened lines","text":"","category":"section"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"line_to_geodetic_width_poly","category":"page"},{"location":"capex/#Karmana.line_to_geodetic_width_poly","page":"CapEx","title":"Karmana.line_to_geodetic_width_poly","text":"line_to_geodetic_width_poly(line::Vector{<: Point2}, width; geodesic = Proj.geod_geodesic(6378137, 1/298.257223563))\n\nReturns a Vector{Point2{Float64}} which represents a polygon which is width metres wide, and follows the path of line.\n\nThis is mostly useful for tracing wide lines on Raster maps.\n\nFundamentally, you can think of this function as creating a polygon from a line, with a specified width.  There's no interpolation, though -  if you want interpolation, pass an interpolated vector of points in.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#The-Karmana.jl-plotting-API","page":"Plotting","title":"The Karmana.jl plotting API","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"You can find examples of how to use all of these functions in the Basic Usage and Poster examples.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"create_page\nindiaoutline\nTernaryColormap","category":"page"},{"location":"plotting/#Karmana.create_page","page":"Plotting","title":"Karmana.create_page","text":"create_page(paper_size, qr_code_link; landscape = automatic, naxes = 1, supertitle = \"Title\", description = \"...\", kwargs...)\n\nCreates a figure of the specified size with the specified arguments, themed for XKDR.  Applies the appropriate paper size theme (theme_a4, theme_a3, etc.)\n\nArguments\n\npaper_size: A symbol representing the desired paper size; can be :a[0/1/2/3/4].  More planned.  In the future, you may also be able to pass a tuple.\nqr_code_link: The contents of the QR code shown at the bottom left of the page.  Must be a string.\n\nKeyword arguments\n\nlandscape = automatic: Decides whether the figure should be in landscape or portrait mode.  If automatic, decides automatically.  To set this manually, set landscape = true or landscape = false.\nnaxes = 1: The number of axes to create in the central grid.  Automatically laid out.  \naxistitles = Makie.automatic: The titles for each axis.  If set to automatic, they will be the positions of the axes in the layout.\nhideaxisdecorations = true: Whether to hide the decorations (tick labels, tick marks, etc.) for each axis.\nhideaxisspines = true: Whether to hide the spines (frame lines) for each axis.\nsupertitle = \"Title\": The title of the figure, in the \"header\" gridlayout.\ndescription = \"Placeholder\": The description of the figure, in the \"footer\" gridlayout (page.description_layout[1, 1]).\npadding: The padding around the figure.  If a number, sets all sides to the same value.  If a tuple, sets the padding to (left, right, top, bottom).\naxisaspect = DataAspect(): Sets the aspect ratio of the axis.  You can set this to nothing if you want the default.\n\nReturns\n\nReturns a NamedTuple containing the following items:\n\nfigure: The Figure in which everything is plotted.\nsupertitle: The Label which serves as the figure's title.\naxis_layout: The GridLayout in which the axes are placed.\naxes: A Matrix{Union{Axis, Nothing}} which contains the axes which can be placed.  If nrows * ncols > naxes, then the remaining positions will be nothing.\ndescription_layout: The GridLayout in which the description is placed.  Has 3 columns and 1 row.  The description label is located in description_layout[1, 1], and [1, 3] is reserved for a box representing the QR code.  You can plot a legend or colorbar in description_layout[1, 2].\ndescription_label: The Label which holds the figure's description.\n\nThe items can be extracted from the named tuple using standard getproperty syntax, as in the following example:\n\npage = create_page(:a4, \"https://xkdr.org\")\npage.figure\npage.axes[i::Int, j::Int]\npage.description_layout\npage.description_label\n...\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Karmana.indiaoutline","page":"Plotting","title":"Karmana.indiaoutline","text":"indiaoutline!(admin_level::Symbol, ids::Vector, vals::Vector{<: Real}; kw_args...)\nindiaoutline!(admin_level::Symbol, dataframe::DataFrame, [id_column::Symbol], value_column::Symbol; kw_args...)\n\nPlots an outline of India, merged with the data passed in.  This data must fundamentally have two things: a column of IDs, and a column of values.  The IDs must match the IDs in the CPHS database,  and the values may be either numbers, or explicit colors.\n\nArguments\n\nadmin_level must be one of :State, :HR, or :District.  \n\nids must be a Vector{Union{Int, Missing}} or a Vector{Int}.  It and vals must have the same length.\n\nAttributes\n\nOne can set the attributes of the various plot elements by setting the values of the corresponding nested Attributes.  These are plot.State, plot.HR, plot.District, and plot.River.\n\nFor example, to set the stroke width of districts to 0.25, one would do:\n\nplot.District.strokewidth[] = 0.25\n\nThe attributes available for State, HR, and District are those of poly; the attributes available for River are those of lines.\n\nCropping the map to provided data\n\nIf the attribute crop_to_data is true, then this crops the map to the bounding box of the provided IDs only, and does not draw any other states/HRs/districts. Otherwise, all available geometries are drawn, but only the provided IDs are colored by their values; the rest of the geometries remain transparent.\n\nControlling how the data is merged\n\nYou can control the column on which data is merged by setting the merge_column and external_merge_column keyword arguments.\n\nmerge_column specifies the key with which to merge of the provided ids to the CPHS database for that admin level.\nexternal_merge_column specifies the key with which to merge the provided ids with the lower admin level geometries.  \n\nFor example, if the provided admin_level is :State, then merge_column will control the key for state_df, and external_merge_column will control the key for hr_df and district_df.\n\nTo see all available attributes and their defaults, have a look at the extended help section by running ??indiaoutline! in the REPL.\n\nExtended help\n\nAvailable attributes, and their values\n\nAvailable attributes and their defaults for Combined{Karmana.indiaoutline} are: \n\n  District               Attributes with 7 entries:\n  label => Districts\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGB{N0f8}(0.549,0.549,0.549)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 98\n  HR                     Attributes with 7 entries:\n  label => HR regions\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGBA{Float32}(0.901961,0.623529,0.0,1.0)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 99\n  Legend                 Attributes with 2 entries:\n  draw => true\n  polypoints => 1\n  River                  Attributes with 5 entries:\n  color => RGB{N0f8}(0.678,0.847,0.902)\n  label => Rivers\n  linewidth => 0.2\n  visible => true\n  zlevel => 97\n  State                  Attributes with 7 entries:\n  label => States\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGB{N0f8}(0.0,0.0,0.0)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 101\n  colormap               :viridis\n  colorrange             MakieCore.Automatic()\n  crop_to_data           false\n  external_merge_column  MakieCore.Automatic()\n  highclip               \"nothing\"\n  lowclip                \"nothing\"\n  merge_column           MakieCore.Automatic()\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Utility-functions","page":"Plotting","title":"Utility functions","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"These functions are more adjacent to data visualization.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Karmana.rgb_to_cmyk_pdf\nKarmana.maps_db_connection\nKarmana.merge_polys","category":"page"},{"location":"plotting/#Karmana.rgb_to_cmyk_pdf","page":"Plotting","title":"Karmana.rgb_to_cmyk_pdf","text":"rgb_to_cmyk_pdf(source_file::AbstractString, dest_file::AbstractString)\n\nRuns Ghostscript on source_file to convert its color schema from RGB to CMYK, and stores the result in dest_file.\n\nThis works well when preparing a PDF for printing, since many printer drivers don't perform the conversion as well as Ghostscript does.  You might see a  green tint on black when printing in color; this ameliorates that to a large degree.\n\nnote: Note\nConverting from RGB to CMYK is a lossy operation, since CMYK is a strict subset of RGB.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Karmana.maps_db_connection","page":"Plotting","title":"Karmana.maps_db_connection","text":"maps_db_connection(user = ENV[\"MAPS_USER\"], password = ENV[\"MAPS_PASSWORD\"])::DBInterface.Connection\n\nReturns a connection to the maps database on data.mayin.org, which must be closed by DBInterface.close!.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Karmana.merge_polys","page":"Plotting","title":"Karmana.merge_polys","text":"merge_polys(polys::AbstractVector{<: Union{Polygon, MultiPolygon}})\n\nMerges a vector of polygons into a single MultiPolygon using ArchGDAL.union.\n\nReturns an ArchGDAL geometry.\n\n\n\n\n\n","category":"function"},{"location":"#Karmana","page":"Home","title":"Karmana","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Karmana.jl is a library which implements utilities to munge CMIE CPHS data and visualize it.  It exposes multiple, orthogonal capabilities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Karmana's visualization utilities are built on the Makie.jl ecosystem, including the GeoMakie.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is built to automate some processes to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Retrieve and process data from the CMIE CPHS and Capex databases\nPlot this data on maps of India.\nCreate coherent and good-looking posters of plots quickly and easily.","category":"page"},{"location":"#Installing","page":"Home","title":"Installing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Karmana.jl is meant to work with CMIE CPHS data, and is not meant to be released to the General registry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/xKDR/Karmana.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To add a specific branch or tag, provide the rev = \"branch_name\" keyword argument.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Karmana.jl implements several orthogonal functions.  For more information, please see the documentation API page, or by running ?funcname in the REPL to access Julia's help mode.","category":"page"},{"location":"#Plotting-and-visualization","page":"Home","title":"Plotting and visualization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"create_page(page_size::Symbol, args...; kwargs...): Creates a Makie.jl figure which is optimized for a figure of the appropriate size, along with a \"header\" row (GridLayout) which has a logo and poster title, and a \"footer\" row (GridLayout) which has a description Label, space for a legend or colorbar, and a QR code with a customizable link.  See the documentation for more!\nindiaoutline!(admin_level::Symbol, ids, vals): A Makie.jl recipe which is able to plot at one of three admin levels (:State, :HR, and :District) - and display the other admin levels' borders.\nTernaryColormap(xgrad, ygrad, zgrad), which creates a \"ternary colormap\" that can be called on x, y, z values for which x + y + z = 1, and returns a ternary interpolated version of the color at the specified coordinates on the plane.","category":"page"},{"location":"#Global-variables","page":"Home","title":"Global variables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All of these variables are populated by Karmana.__init__(), and can their values can be accessed by, for example, Karmana.state_df[] (note the empty square brackets, which indicate that you're accessing the value of the Ref).","category":"page"},{"location":"","page":"Home","title":"Home","text":"state_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's states.\nhr_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's homogeneous regions, as defined by CMIE.\ndistrict_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's districts.\nindia_rivers::Ref{ArchGDAL.IGeometry}: An ArchGDAL.IGeometry which holds the intersection of the rivers of the world with the border of India.","category":"page"},{"location":"#CPHS-helper-functions","page":"Home","title":"CPHS helper functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Karmana has several CPHS helper functions to parse data.","category":"page"},{"location":"#Capex-helper-functions","page":"Home","title":"Capex helper functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Karmana has some parsers for CMIE Capex data lat/long strings.","category":"page"},{"location":"#Spatial-utilities","page":"Home","title":"Spatial utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Karmana has some geodetic/spatial utilities, like annular_ring and line_to_geodetic_width_poly.  See the docs and examples for more information!","category":"page"},{"location":"#Environment-variables","page":"Home","title":"Environment variables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Karmana can be configured by the following environment variables:","category":"page"},{"location":"","page":"Home","title":"Home","text":"KARMANA_DISTRICT_SHAPEFILE which points to a shapefile which Karmana should use to populate the district, HR and state dataframes.  Note that there are a lot of assumptions made on the structure of the shapefile - look at the code of Karmana.__init__() to see what these are.\nKARMANA_APPLY_SHAPEFILE_PATCHES indicates whether to apply certain patches to the shapefile (\"true\") or not (\"false\").  Defaults to true.\nKARMANA_RIVER_SHAPEFILE indicates the path to some shapefile which contains a selection of rivers (usually as linestrings).  If not found, Karmana will download this data from UNESCO.","category":"page"}]
}

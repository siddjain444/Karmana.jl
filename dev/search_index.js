var documenterSearchIndex = {"docs":
[{"location":"examples/geodesic/","page":"-","title":"-","text":"Exploring the geodesic utilities that Karmana provides","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"using Proj, GeoInterface, Rasters, CairoMakie, Karmana","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"Geodetic circles - the locus of all points which are physically radius away from the center","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"initial_line = Karmana.get_geodetic_circle(72, 50, 9000)\nlines(initial_line; axis = (; aspect = DataAspect()))","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"fig, ax, circ_plt = lines(Karmana.get_geodetic_circle(72, 50, 20000); linewidth = 2, axis = (; aspect = DataAspect()))\ncent_plot = scatter!(ax, [Point2f(72, 50)])\nfig","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"Geodetically expanding lines - equal physical width lines","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"poly_line = Karmana.line_to_geodetic_width_poly(initial_line, 2000)\npoly_line = Karmana.line_to_geodetic_width_poly(Point2f.(LinRange(0, 6, 100), sin.(LinRange(0, 6, 100))), 2000)\n\npoly(poly_line; axis = (; aspect = DataAspect()))","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"Rasters.rasterize works on this polygon!","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"annular_polygon = Makie.GeometryBasics.Polygon(\n    Karmana.get_geodetic_circle(72, 50, 90000),\n    [reverse(Karmana.get_geodetic_circle(72, 50, 20000))] # note the `reverse` here - this is for the intersection fill rule.\n    )\n\npoly(annular_polygon; axis = (; aspect = DataAspect()))","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"Those were the building blocks, but let's do something fun.","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"Let's get the nightlights data for India, and calculate their nightlights over time.","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"using CSV, DataFrames, Statistics\n\nnightlights_raster = view(Raster(\"/Users/anshul/Documents/Business/India/XKDR/code/maps/DATA/updated_india.nc\"; lazy = true), :, :, 1, :)\n\nxs, ys = dims(nightlights_raster)\nnightlights_bbox = Makie.BBox(extrema(xs)..., extrema(ys)...)\n\ncity_dataset = CSV.read(\"/Users/anshul/Downloads/simplemaps_worldcities_basicv1.75/worldcities.csv\", DataFrame)\n\nlats, lons = city_dataset[!, :lat], city_dataset[!, :lng]\n\nindia_cities = dropmissing(city_dataset[in.(Point2f.(lons, lats), (nightlights_bbox,)), :])\nsort!(india_cities, :population; order = Base.Reverse)","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"Top 8 cities in India by population","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"india_cities.city_positions = Point2{Float64}.(india_cities[!, :lng], india_cities[!, :lat])\n\none_light_from_ring = Karmana.annular_ring.(Statistics.mean, view(nightlights_raster, :, :, 1), india_cities.city_positions[1]... #= lon, lat=#, 15000, 3000)\n\nlights_from_ring = Karmana.annular_ring.(Statistics.mean, nightlights_raster, india_cities.city_positions[1]..., 15000, 3000)","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"plot","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"f, a, p = lines(lights_from_ring, label = \"Mean radiance\", axis = (; title = \"Mean nighttime light radiance around Mumbai over time\", xlabel = \"Time (months)\", ylabel = \"Radiance\"))\naxislegend(a, position = :lt)\na.title = \"Mean nighttime light radiance around Delhi over time\"\nf","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"","category":"page"},{"location":"examples/geodesic/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"cphs/#CPHS-utilities","page":"CPHS","title":"CPHS utilities","text":"","category":"section"},{"location":"cphs/","page":"CPHS","title":"CPHS","text":"get_HR_number\nget_sentiment_props","category":"page"},{"location":"cphs/#Karmana.get_HR_number","page":"CPHS","title":"Karmana.get_HR_number","text":"get_HR_number(hr::Union{String, Missing})::Union{Int, Missing}\n\nExtracts the number from a string of a form \"HR ???\" and returns it. If the input is missing, then missing is returned.\n\n\n\n\n\n","category":"function"},{"location":"cphs/#Karmana.get_sentiment_props","page":"CPHS","title":"Karmana.get_sentiment_props","text":"get_sentiment_props(df, sentiment_key; good = \"Good times\", bad = \"Bad times\", uncertain = \"Uncertain times\")\n\nTakes in a DataFrame from the CPHS aspirational wave database, and returns a tuple of (bad_prop, good_prop, uncertain_prop).\n\nThe keys can be changed by keyword arguments; fundamentally, this is a helper function to extract proportions from a three-value system.\n\n\n\n\n\n","category":"function"},{"location":"financial/#Financial-utilities","page":"Financial utilities","title":"Financial utilities","text":"","category":"section"},{"location":"financial/","page":"Financial utilities","title":"Financial utilities","text":"Nothing here, but planned ","category":"page"},{"location":"financial/#Nominal-to-real-value","page":"Financial utilities","title":"Nominal to real value","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Preliminary setup Activate the correct environment","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"using Pkg; Pkg.activate(@__DIR__)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Set an environment variable which tells Karmana.jl, when loaded, to utilize the maps/DATA india shapefile, instead of having it get that from the database.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"ENV[\"KARMANA_DISTRICT_SHAPEFILE\"] = joinpath(dirname(dirname(@__DIR__)), \"DATA\", \"INDIA_SHAPEFILES\", \"Districts_States_HR\", \"2011_Districts_State_HR.shp\")\n\n\nusing Karmana\nusing Makie, CairoMakie # backend for Makie.jl - necessary if you want to save a plot\nusing Makie.Colors","category":"page"},{"location":"examples/demo/#Basic-usage-for-Karmana","page":"Basic Usage","title":"Basic usage for Karmana","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Before you run this code, make sure that you have read the Makie tutorial at docs.makie.org first!","category":"page"},{"location":"examples/demo/#Creating-a-page","page":"Basic Usage","title":"Creating a page","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, create a page of the appropriate size with xKDR poster formatting using the create_page function.  This returns a NamedTuple with a figure, some axes, and a customized layout. You must provide the page size you want to the function, as a Symbol (:a4-:a0 are supported for now).","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a4)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"By default, the create_page function creates only one axis.  It returns all axes as a matrix, so that it's easy and intuitive to refer to them in a grid.","category":"page"},{"location":"examples/demo/#Plotting-using-indiaoutline!","page":"Basic Usage","title":"Plotting using indiaoutline!","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"The IndiaOutline plot type was designed specifically for CPHS state, HR, or district level data, and automates a lot of the data munging you may have to do otherwise. You can call it in one of the following ways:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Provide an admin level Symbol, a vector of IDs for that admin level, and a vector of values for those IDs\nProvide a DataFrame, its ID column as a symbol, and its value column as a symbol\nProvide an","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"What we're doing below is the first option, which is also the most versatile. We're accessing","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"outline_plt = indiaoutline!(\n    page.axes[1, 1],\n    :HR,                      # admin level symbol\n    [70, 71, 72, 73, 74, 75], # IDs\n    rand(6);                  # values\n    HR = (strokecolor = to_color(:blue),),\n    colormap = :Reds\n)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Now, we display the page again (assuming you're using CairoMakie, graphs do not update interactively)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"You can alter the attributes of an IndiaOutline plot after the fact, using the standard Makie attribute updating syntax. For example, you can change the colormap like this:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"outline_plt.plots[2].colormap[] = :Oranges\n\npage","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"You can also change the attributes of the IndiaOutline plot itself, like this: (note the nested attributes here, if you want to know more, read the docstring).","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"outline_plt.State.strokewidth[]    = 0.2 #* 2 * 2\noutline_plt.HR.strokewidth[]       = 0.2 #* 2 * 2\noutline_plt.HR.strokecolor[]       = to_color(:blue)\noutline_plt.District.strokewidth[] = 0.1\n\npage","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"There's also a description, and you might note the space between that and the QR code, which is another layout cell which you can use for a legend, or a colorbar.  Here's how you can add a colorbar there (note that it should be horizontal):","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"cb = Colorbar(\n    page.description_layout[1, 2], # this is the empty layout cell into which you can place a colorbar``\n    outline_plt.plots[2].plots[1]; # this is the plot - TODO make this easier\n    flipaxis = false,              # this keeps the colorbar's axis at the bottom\n    vertical = false               # this sets the colorbar's orientation to be horizontal\n)\n\npage","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"this is how to save a page object, if you want to save(\"my_map.png\", page.figure; px_per_unit = 3) save(\"my_map.pdf\", page.figure; pt_per_unit = 1)","category":"page"},{"location":"examples/demo/#Using-create_page","page":"Basic Usage","title":"Using create_page","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Multiple axes default to landscape, but that specific behaviour can be changed on the basis of paper size.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a4; landscape = true)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"You can define a set number of axes, and they will be arranged in a grid.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a4; naxes = 2)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Alternatively, you can also define the number of rows and columns.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a4; naxes = (2, 3))","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"There are multiple options for paper size, ranging from a4 to a0.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page = create_page(:a3)\n\n\npage = create_page(:a3; landscape = false, naxes = 4)\nsetproperty!.(page.axes, :aspect, (DataAspect(),))\nindiaoutline!.(page.axes, (:State,), (:all,))\npage","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"The function is integrated well with Makie's themes, and we could make our own for e.g. BQ or BS, following their style.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Any plots on this new page follow the theme with which it was created.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"with_theme(theme_black()) do\n    create_page(:a3)\nend","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"TODO: resurrect the draw_boxes function This is what the layout looks like: draw_boxes(page.figure.layout)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"page.figure","category":"page"},{"location":"examples/demo/#Handling-raster-data","page":"Basic Usage","title":"Handling raster data","text":"","category":"section"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Most raster data in Julia is handled by the Raster type from the Rasters.jl package. Makie.jl supports plotting Rasters efficiently using the heatmap function; however, if you want to display your data in 3D, you can also use surface!.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, we load Rasters (and GeoInterface, which is a common interface for vector data):","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"using Rasters, GeoInterface","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, we extract India's bounding box (I could have hardcoded this, but was too lazy).","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"This code merges all of the state geometries of India (including union territories) and finds their bounding box.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"india_bbox = GeoInterface.extent(Karmana.merge_polys(Karmana.state_df[].geometry))","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Now, we create a raster with 30x30 pixels, and fill it with a field of a known function.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, we create the field:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"field = Makie.peaks(30) # this is essentially a convenience function which generates a matrix of data","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Then, we can create the raster, using Rasters.X and Rasters.Y to indicate dimensions.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"mydims = (X(LinRange(india_bbox.X..., 30)), Y(LinRange(india_bbox.Y..., 30)))\nindia_raster = Raster(field, mydims)","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"This is the raster.  We can plot it using heatmap, surface, or even contour! Any Makie plot type which is SurfaceLike() will work.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"First, let's make sure that the raster looks the same as the original data:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"fig, ax1, plt1 = surface(field; axis = (title = \"Original data\", type = Axis3))\nax2, plt2 = surface(fig[1, 2], india_raster; axis = (title = \"Raster\", type = Axis3))\nfig","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Hey, these look practically identical - except for the x and y values on the left plot, which are actually the bounding box for India!","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Now, let's plot the raster using heatmap:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"fig, ax, plt = heatmap(india_raster; axis = (title = \"Heatmap\", aspect = DataAspect()))","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"Note the inclusion of aspect = DataAspect() in that heatmap call - this ensures that the pixels of the map reflect physical reality.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"indiaoutline!(ax, :State, :all; merge_column = :st_nm, external_merge_column = :st_nm)\nfig","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"This is clearly unrealistic, but otherwise correct!","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"TODOs:","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"[ ] Add a draw_boxes function to draw boxes around the layout cells\n[ ] Change the raster example to use Rasters.jl data from BioClim.","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"","category":"page"},{"location":"examples/demo/","page":"Basic Usage","title":"Basic Usage","text":"This page was generated using Literate.jl.","category":"page"},{"location":"capex/#CMIE-CapEx-utilities","page":"CapEx","title":"CMIE CapEx utilities","text":"","category":"section"},{"location":"capex/#Data-munging","page":"CapEx","title":"Data munging","text":"","category":"section"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"Apply these functions to columns from the CapEx database.","category":"page"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"latlong_string_to_points\npoints_weights","category":"page"},{"location":"capex/#Karmana.latlong_string_to_points","page":"CapEx","title":"Karmana.latlong_string_to_points","text":"latlong_string_to_points(latlong_string)\n\nParses a string of the form lat1,long1 : lat2,long2 : lat3,long3 : ...  and returns a Vector of Point2e which define points as (long, lat).  \n\nIs robust to cutoff errors and other potential issues.\n\n\n\n\n\n","category":"function"},{"location":"capex/#Karmana.points_weights","page":"CapEx","title":"Karmana.points_weights","text":"points_weights(latlong_strings::Vector{:< AbstractString}, costs::Vector{<: Real})\n\nParses strings of the form lat1,long1 : lat2,long2 : lat3,long3 : ...  and returns a Vector of Point2e which define points as (long, lat), as well as a vector of weights per point.  If the string has more than one point defined,  the weight is spread across all n points such that each point has a weight of cost[i]/n.\n\nReturns (::Vector{Point2e}, ::Vector{<: Real}).\n\nnote: Note\nThis format of data is often found in CMIE capex location data.\n\n\n\n\n\n","category":"function"},{"location":"capex/#Geographic-utilities","page":"CapEx","title":"Geographic utilities","text":"","category":"section"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"We also have geographic utilities, which use e.g. Rasters.  ","category":"page"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"note: Note\nMaybe this section should be its own page, since the functionality is pretty orthogonal?","category":"page"},{"location":"capex/#Annular-rings","page":"CapEx","title":"Annular rings","text":"","category":"section"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"annular_ring","category":"page"},{"location":"capex/#Karmana.annular_ring","page":"CapEx","title":"Karmana.annular_ring","text":"annular_ring(f, source::Raster, lon, lat, outer_radius, inner_radius)\n\nReturns the result of applying f to the subset of source which is masked by the annular ring defined by lon, lat, outer_radius, inner_radius. The annular ring is constructed in geodetic space, i.e., distance is physically preserved.\n\nArguments\n\nf is a function which takes a Raster and returns a value.  This is the function which will be applied to the subset of source which is masked by the constructed annular ring. The result of f is returned.\nsource is a Raster which will be masked by the annular ring.  This can be 2D, in which case annular_ring will return a single value, or 3D, in which case annular_ring will return a Vector of values.\nlon, lat are the coordinates of the centre of the annular ring, in degrees.\nouter_radius and inner_radius are the outer and inner radii of the annular ring, in metres.\n\nHow it works\n\nFirst, an annular ring polygon is created (in geodetic space, using get_geodetic_circle).\nNext, the extent of the annular ring polygon is computed, and the source raster is subsetted to that extent.  This is for efficiency, and so that the minimum possible number of multiplications are performed.\nThe annular ring polygon is rasterized, using Rasters.boolmask.\nThe subsetted source raster is multiplied by the rasterized annular ring polygon.\nFinally, f is applied to the result of the multiplication.\n\n\n\n\n\n","category":"function"},{"location":"capex/#Geodetically-widened-lines","page":"CapEx","title":"Geodetically widened lines","text":"","category":"section"},{"location":"capex/","page":"CapEx","title":"CapEx","text":"line_to_geodetic_width_poly","category":"page"},{"location":"capex/#Karmana.line_to_geodetic_width_poly","page":"CapEx","title":"Karmana.line_to_geodetic_width_poly","text":"line_to_geodetic_width_poly(line::Vector{<: Point2}, width; geodesic = Proj.geod_geodesic(6378137, 1/298.257223563))\n\nReturns a Vector{Point2{Float64}} which represents a polygon which is width metres wide, and follows the path of line.\n\nThis is mostly useful for tracing wide lines on Raster maps.\n\nFundamentally, you can think of this function as creating a polygon from a line, with a specified width.  There's no interpolation, though -  if you want interpolation, pass an interpolated vector of points in.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#The-Karmana.jl-plotting-API","page":"Plotting","title":"The Karmana.jl plotting API","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"create_page\nindiaoutline!\nindiaoutline\nTernaryColormap","category":"page"},{"location":"plotting/#Karmana.create_page","page":"Plotting","title":"Karmana.create_page","text":"create_page(paper_size, qr_code_link; landscape = automatic, naxes = 1, supertitle = \"Title\", description = \"...\", kwargs...)\n\nCreates a figure of the specified size with the specified arguments, themed for XKDR.  Applies the appropriate paper size theme (theme_a4, theme_a3, etc.)\n\nArguments\n\npaper_size: A symbol representing the desired paper size; can be :a[0/1/2/3/4].  More planned.  In the future, you may also be able to pass a tuple.\nqr_code_link: The contents of the QR code shown at the bottom left of the page.  Must be a string.\n\nKeyword arguments\n\nlandscape = automatic: Decides whether the figure should be in landscape or portrait mode.  If automatic, decides automatically.  To set this manually, set landscape = true or landscape = false.\nnaxes = 1: The number of axes to create in the central grid.  Automatically laid out.  \naxistitles = Makie.automatic: The titles for each axis.  If set to automatic, they will be the positions of the axes in the layout.\nhideaxisdecorations = true: Whether to hide the decorations (tick labels, tick marks, etc.) for each axis.\nhideaxisspines = true: Whether to hide the spines (frame lines) for each axis.\nsupertitle = \"Title\": The title of the figure, in the \"header\" gridlayout.\ndescription = \"Placeholder\": The description of the figure, in the \"footer\" gridlayout (page.description_layout[1, 1]).\npadding: The padding around the figure.  If a number, sets all sides to the same value.  If a tuple, sets the padding to (left, right, top, bottom).\naxisaspect = DataAspect(): Sets the aspect ratio of the axis.  You can set this to nothing if you want the default.\n\nReturns\n\nReturns a NamedTuple containing the following items:\n\nfigure: The Figure in which everything is plotted.\nsupertitle: The Label which serves as the figure's title.\naxis_layout: The GridLayout in which the axes are placed.\naxes: A Matrix{Union{Axis, Nothing}} which contains the axes which can be placed.  If nrows * ncols > naxes, then the remaining positions will be nothing.\ndescription_layout: The GridLayout in which the description is placed.  Has 3 columns and 1 row.  The description label is located in description_layout[1, 1], and [1, 3] is reserved for a box representing the QR code.  You can plot a legend or colorbar in description_layout[1, 2].\ndescription_label: The Label which holds the figure's description.\n\nThe items can be extracted from the named tuple using standard getproperty syntax, as in the following example:\n\npage = create_page(:a4, \"https://xkdr.org\")\npage.figure\npage.axes[i::Int, j::Int]\npage.description_layout\npage.description_label\n...\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Karmana.indiaoutline!","page":"Plotting","title":"Karmana.indiaoutline!","text":"indiaoutline!(admin_level::Symbol, ids::Vector, vals::Vector{<: Real}; kw_args...)\nindiaoutline!(admin_level::Symbol, dataframe::DataFrame, [id_column::Symbol], value_column::Symbol; kw_args...)\n\nPlots an outline of India, merged with the data passed in.  This data must fundamentally have two things: a column of IDs, and a column of values.  The IDs must match the IDs in the CPHS database,  and the values may be either numbers, or explicit colors.\n\nArguments\n\nadmin_level must be one of :State, :HR, or :District.  \n\nids must be a Vector{Union{Int, Missing}} or a Vector{Int}.  It and vals must have the same length.\n\nAttributes\n\nOne can set the attributes of the various plot elements by setting the values of the corresponding nested Attributes.  These are plot.State, plot.HR, plot.District, and plot.River.\n\nFor example, to set the stroke width of districts to 0.25, one would do:\n\nplot.District.strokewidth[] = 0.25\n\nThe attributes available for State, HR, and District are those of poly; the attributes available for River are those of lines.\n\nCropping the map to provided data\n\nIf the attribute crop_to_data is true, then this crops the map to the bounding box of the provided IDs only, and does not draw any other states/HRs/districts. Otherwise, all available geometries are drawn, but only the provided IDs are colored by their values; the rest of the geometries remain transparent.\n\nControlling how the data is merged\n\nYou can control the column on which data is merged by setting the merge_column and external_merge_column keyword arguments.\n\nmerge_column specifies the key with which to merge of the provided ids to the CPHS database for that admin level.\nexternal_merge_column specifies the key with which to merge the provided ids with the lower admin level geometries.  \n\nFor example, if the provided admin_level is :State, then merge_column will control the key for state_df, and external_merge_column will control the key for hr_df and district_df.\n\nTo see all available attributes and their defaults, have a look at the extended help section by running ??indiaoutline! in the REPL.\n\nExtended help\n\nAvailable attributes, and their values\n\nAvailable attributes and their defaults for MakieCore.Combined{Karmana.indiaoutline!} are: \n\n\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Karmana.indiaoutline","page":"Plotting","title":"Karmana.indiaoutline","text":"indiaoutline!(admin_level::Symbol, ids::Vector, vals::Vector{<: Real}; kw_args...)\nindiaoutline!(admin_level::Symbol, dataframe::DataFrame, [id_column::Symbol], value_column::Symbol; kw_args...)\n\nPlots an outline of India, merged with the data passed in.  This data must fundamentally have two things: a column of IDs, and a column of values.  The IDs must match the IDs in the CPHS database,  and the values may be either numbers, or explicit colors.\n\nArguments\n\nadmin_level must be one of :State, :HR, or :District.  \n\nids must be a Vector{Union{Int, Missing}} or a Vector{Int}.  It and vals must have the same length.\n\nAttributes\n\nOne can set the attributes of the various plot elements by setting the values of the corresponding nested Attributes.  These are plot.State, plot.HR, plot.District, and plot.River.\n\nFor example, to set the stroke width of districts to 0.25, one would do:\n\nplot.District.strokewidth[] = 0.25\n\nThe attributes available for State, HR, and District are those of poly; the attributes available for River are those of lines.\n\nCropping the map to provided data\n\nIf the attribute crop_to_data is true, then this crops the map to the bounding box of the provided IDs only, and does not draw any other states/HRs/districts. Otherwise, all available geometries are drawn, but only the provided IDs are colored by their values; the rest of the geometries remain transparent.\n\nControlling how the data is merged\n\nYou can control the column on which data is merged by setting the merge_column and external_merge_column keyword arguments.\n\nmerge_column specifies the key with which to merge of the provided ids to the CPHS database for that admin level.\nexternal_merge_column specifies the key with which to merge the provided ids with the lower admin level geometries.  \n\nFor example, if the provided admin_level is :State, then merge_column will control the key for state_df, and external_merge_column will control the key for hr_df and district_df.\n\nTo see all available attributes and their defaults, have a look at the extended help section by running ??indiaoutline! in the REPL.\n\nExtended help\n\nAvailable attributes, and their values\n\nAvailable attributes and their defaults for MakieCore.Combined{Karmana.indiaoutline} are: \n\n  District               Attributes with 7 entries:\n  label => Districts\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGB{N0f8}(0.549,0.549,0.549)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 98\n  HR                     Attributes with 7 entries:\n  label => HR regions\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGBA{Float32}(0.901961,0.623529,0.0,1.0)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 99\n  Legend                 Attributes with 2 entries:\n  draw => true\n  polypoints => 1\n  River                  Attributes with 5 entries:\n  color => RGB{N0f8}(0.678,0.847,0.902)\n  label => Rivers\n  linewidth => 0.2\n  visible => true\n  zlevel => 97\n  State                  Attributes with 7 entries:\n  label => States\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGB{N0f8}(0.0,0.0,0.0)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 101\n  colormap               :viridis\n  colorrange             MakieCore.Automatic()\n  crop_to_data           false\n  external_merge_column  MakieCore.Automatic()\n  highclip               \"nothing\"\n  lowclip                \"nothing\"\n  merge_column           MakieCore.Automatic()\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Karmana.TernaryColormap","page":"Plotting","title":"Karmana.TernaryColormap","text":"struct TernaryColormap\nTernaryColormap(; xmap, ymap, zmap)\n\nRepresents a ternary colormap.  \n\nConstruct by passing three PlotUtils.ColorGradients or objects which can be converted to them (symbols, strings).\n\nCall by using the ternary colormap object (tmap) as a callable - methods include tmap(x, y, z) or tmap(Point3f(...)) or tmap((x, y, z)).  Returns an RGBAf object when called.\n\nVisualize by calling Makie.plot(tmap).\n\n\n\n\n\n","category":"type"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Modules = [Karmana]","category":"page"},{"location":"plotting/#Karmana.Karmana","page":"Plotting","title":"Karmana.Karmana","text":"Karmana\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)\n\nKarmana.jl is a library which implements utilities to munge CMIE CPHS data and visualize it.  It exposes multiple, orthogonal capabilities.\n\nKarmana's visualization utilities are built on the Makie.jl ecosystem, including the GeoMakie.jl package.\n\nThe package is built to automate some processes to:\n\nRetrieve and process data from the CMIE CPHS and Capex databases\nPlot this data on maps of India.\nCreate coherent and good-looking posters of plots quickly and easily.\n\nInstalling\n\nKarmana.jl is meant to work with CMIE CPHS data, and is not meant to be released to the General registry.\n\nusing Pkg\nPkg.add(url = \"https://github.com/xKDR/Karmana.jl\")\n\nTo add a specific branch or tag, provide the rev = \"branch_name\" keyword argument.\n\nSome functionality requires access to the xKDR maps database.  This can take one of two forms:\n\nDatabase credentials encoded in the environment variables \"MAPS_USER\" and \"MAPS_PASSWORD\".\nA shapefile whose location is indicated by the environment variable \"KARMANA_DISTRICT_SHAPEFILE\".\n\n\nYou can either set these before loading Karmana.jl, or call Karmana.__init__() after setting it to reset the state_df, hr_df, and district_df global variables (described below).\n\nUsage\n\nKarmana.jl implements several orthogonal functions.  For more information, please see the documentation API page, or by running ?funcname in the REPL to access Julia's help mode.\n\nPlotting and visualization\n\ncreate_page(page_size::Symbol, args...; kwargs...): Creates a Makie.jl figure which is optimized for a figure of the appropriate size, along with a \"header\" row (GridLayout) which has a logo and poster title, and a \"footer\" row (GridLayout) which has a description Label, space for a legend or colorbar, and a QR code with a customizable link.  See the documentation for more!\nindiaoutline!(admin_level::Symbol, ids, vals): A Makie.jl recipe which is able to plot at one of three admin levels (:State, :HR, and :District) - and display the other admin levels' borders.\nTernaryColormap(xgrad, ygrad, zgrad), which creates a \"ternary colormap\" that can be called on x, y, z values for which x + y + z = 1, and returns a ternary interpolated version of the color at the specified coordinates on the plane.\n\nGlobal variables\n\nAll of these variables are populated by Karmana.__init__(), and can their values can be accessed by, for example, Karmana.state_df[] (note the empty square brackets, which indicate that you're accessing the value of the Ref).\n\nstate_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's states.\nhr_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's homogeneous regions, as defined by CMIE.\ndistrict_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's districts.\nindia_rivers::Ref{ArchGDAL.IGeometry}: An ArchGDAL.IGeometry which holds the intersection of the rivers of the world with the border of India.\n\nCPHS helper functions\n\nCapex helper functions\n\n\n\n\n\n","category":"module"},{"location":"plotting/#Karmana.district_df","page":"Plotting","title":"Karmana.district_df","text":"Contains the District dataframe\n\n\n\n\n\n","category":"constant"},{"location":"plotting/#Karmana.hr_df","page":"Plotting","title":"Karmana.hr_df","text":"Contains the HR dataframe\n\n\n\n\n\n","category":"constant"},{"location":"plotting/#Karmana.india_rivers","page":"Plotting","title":"Karmana.india_rivers","text":"Contains an ArchGDAL.IGeometry which contains a multilinestring of the intersection of the world's rivers with India.\n\n\n\n\n\n","category":"constant"},{"location":"plotting/#Karmana.state_df","page":"Plotting","title":"Karmana.state_df","text":"Contains the State dataframe\n\n\n\n\n\n","category":"constant"},{"location":"plotting/#Karmana.__init__-Tuple{}","page":"Plotting","title":"Karmana.__init__","text":"Karmana.__init__()\n\nInitializes the package by loading geometries.  This is only really relevant to the indiaoutline recipe.\n\nFirst, load the state, hr and district geometries of India from data.mayin.org, or the provided cache path. Then, compute the intersection between the world's rivers (provided by env variable) and India, or load from cache stored in scratchspace.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana._missing_in-Tuple{Any, Any}","page":"Plotting","title":"Karmana._missing_in","text":"_missing_in(x, set)\n\nHandles the case where x is missing, which in  does not.  If x is missing and there is a missing value in set, then returns true.  If there is no missing value in set, returns false.  Otherwise, the behaviour is the same as Base.in.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana._prepare_merged_geom_dataframe-Tuple{DataFrames.DataFrame, Vararg{Symbol}}","page":"Plotting","title":"Karmana._prepare_merged_geom_dataframe","text":"prepare_merged_geom_dataframe(df::DataFrame, hr_column_id::Symbol; capture_cols::Tuple{Symbol})\n\nPrepares a dataframe of merged geometries by grouping df by hr_column_id.   The values of each of the capture_cols in the first row of each group are also  included in the new dataframe, along with the value of  hr_column_id.   Each group in the input corresponds to a row in the output dataframe.\n\nThis method assumes that there is a geometry column in the DataFrame which contains objects which have a MultiPolygonTrait in GeoInterface.\n\nReturns a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana._set_plot_z-Tuple{Any, Real}","page":"Plotting","title":"Karmana._set_plot_z","text":"_set_plot_z(plot, zlevel::Real)\n\nSets the plot's z-level to the provided argument, leaving the rest of the translation attributes  the same.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.annular_ring-Union{Tuple{T}, Tuple{F}, Tuple{F, Rasters.Raster{T, 2, D, R, A} where {D<:Tuple, R<:Tuple, A<:AbstractMatrix{T}}, Any, Any, Any, Any}} where {F, T}","page":"Plotting","title":"Karmana.annular_ring","text":"annular_ring(f, source::Raster, lon, lat, outer_radius, inner_radius)\n\nReturns the result of applying f to the subset of source which is masked by the annular ring defined by lon, lat, outer_radius, inner_radius. The annular ring is constructed in geodetic space, i.e., distance is physically preserved.\n\nArguments\n\nf is a function which takes a Raster and returns a value.  This is the function which will be applied to the subset of source which is masked by the constructed annular ring. The result of f is returned.\nsource is a Raster which will be masked by the annular ring.  This can be 2D, in which case annular_ring will return a single value, or 3D, in which case annular_ring will return a Vector of values.\nlon, lat are the coordinates of the centre of the annular ring, in degrees.\nouter_radius and inner_radius are the outer and inner radii of the annular ring, in metres.\n\nHow it works\n\nFirst, an annular ring polygon is created (in geodetic space, using get_geodetic_circle).\nNext, the extent of the annular ring polygon is computed, and the source raster is subsetted to that extent.  This is for efficiency, and so that the minimum possible number of multiplications are performed.\nThe annular ring polygon is rasterized, using Rasters.boolmask.\nThe subsetted source raster is multiplied by the rasterized annular ring polygon.\nFinally, f is applied to the result of the multiplication.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.create_page-2","page":"Plotting","title":"Karmana.create_page","text":"create_page(paper_size, qr_code_link; landscape = automatic, naxes = 1, supertitle = \"Title\", description = \"...\", kwargs...)\n\nCreates a figure of the specified size with the specified arguments, themed for XKDR.  Applies the appropriate paper size theme (theme_a4, theme_a3, etc.)\n\nArguments\n\npaper_size: A symbol representing the desired paper size; can be :a[0/1/2/3/4].  More planned.  In the future, you may also be able to pass a tuple.\nqr_code_link: The contents of the QR code shown at the bottom left of the page.  Must be a string.\n\nKeyword arguments\n\nlandscape = automatic: Decides whether the figure should be in landscape or portrait mode.  If automatic, decides automatically.  To set this manually, set landscape = true or landscape = false.\nnaxes = 1: The number of axes to create in the central grid.  Automatically laid out.  \naxistitles = Makie.automatic: The titles for each axis.  If set to automatic, they will be the positions of the axes in the layout.\nhideaxisdecorations = true: Whether to hide the decorations (tick labels, tick marks, etc.) for each axis.\nhideaxisspines = true: Whether to hide the spines (frame lines) for each axis.\nsupertitle = \"Title\": The title of the figure, in the \"header\" gridlayout.\ndescription = \"Placeholder\": The description of the figure, in the \"footer\" gridlayout (page.description_layout[1, 1]).\npadding: The padding around the figure.  If a number, sets all sides to the same value.  If a tuple, sets the padding to (left, right, top, bottom).\naxisaspect = DataAspect(): Sets the aspect ratio of the axis.  You can set this to nothing if you want the default.\n\nReturns\n\nReturns a NamedTuple containing the following items:\n\nfigure: The Figure in which everything is plotted.\nsupertitle: The Label which serves as the figure's title.\naxis_layout: The GridLayout in which the axes are placed.\naxes: A Matrix{Union{Axis, Nothing}} which contains the axes which can be placed.  If nrows * ncols > naxes, then the remaining positions will be nothing.\ndescription_layout: The GridLayout in which the description is placed.  Has 3 columns and 1 row.  The description label is located in description_layout[1, 1], and [1, 3] is reserved for a box representing the QR code.  You can plot a legend or colorbar in description_layout[1, 2].\ndescription_label: The Label which holds the figure's description.\n\nThe items can be extracted from the named tuple using standard getproperty syntax, as in the following example:\n\npage = create_page(:a4, \"https://xkdr.org\")\npage.figure\npage.axes[i::Int, j::Int]\npage.description_layout\npage.description_label\n...\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Karmana.do_geoquery-Tuple{Any, Any}","page":"Plotting","title":"Karmana.do_geoquery","text":"do_geoquery(connection, layer; geometrycols = [\"SHAPE\"])::DataFrame\n\nPerforms a SELECT * FROM $layer operation on the database which connection points to, but all geometrycols are additionally wrapped in ST_AsBinary, which converts geometries from SQL format (which has an extra CRS indicator) to well known binary (WKB) format, which is parseable by e.g. ArchGDAL (or WellKnownGeometry.jl, which is substantially slower).\n\nWKB columns are given the suffix _wkb to differentiate them from the original columns.  \n\nResults are returned as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.get_HR_number-Tuple{String}","page":"Plotting","title":"Karmana.get_HR_number","text":"get_HR_number(hr::Union{String, Missing})::Union{Int, Missing}\n\nExtracts the number from a string of a form \"HR ???\" and returns it. If the input is missing, then missing is returned.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.get_geodetic_circle-Tuple{Any, Any, Any}","page":"Plotting","title":"Karmana.get_geodetic_circle","text":"get_geodetic_circle(lon, lat, radius; npoints = 100, geodesic = Proj.geod_geodesic(6378137, 1/298.257223563))\n\nReturns a Vector of Makie.Point2f which represent a circle of radius radius centered at lon, lat, computed in geodetic coordinates.\n\nlon and lat are in degrees, radius is in metres.\n\n!!! note Performance     Because this calls out to C, it's a bit slower than I'd like it to be, but not by much.  100 points takes about 28ms on my machine, a souped up Macbook Pro M1.\n\nMaking annular rings\n\nTo create an annular ring, it's sufficient to say:\n\nlon, lat = 72, 19\ninner_radius = 1000\nouter_radius = 10000\nannular_polygon = GeometryBasics.Polygon(\n        get_geodetic_circle(lon, lat, outer_radius), \n        [reverse(get_geodetic_circle(lon, lat, inner_radius))] # note the `reverse` here - this is for the intersection fill rule.\n)\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.get_sentiment_props-Tuple{Any, Any}","page":"Plotting","title":"Karmana.get_sentiment_props","text":"get_sentiment_props(df, sentiment_key; good = \"Good times\", bad = \"Bad times\", uncertain = \"Uncertain times\")\n\nTakes in a DataFrame from the CPHS aspirational wave database, and returns a tuple of (bad_prop, good_prop, uncertain_prop).\n\nThe keys can be changed by keyword arguments; fundamentally, this is a helper function to extract proportions from a three-value system.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.indiaoutline!-Tuple","page":"Plotting","title":"Karmana.indiaoutline!","text":"indiaoutline!(admin_level::Symbol, ids::Vector, vals::Vector{<: Real}; kw_args...)\nindiaoutline!(admin_level::Symbol, dataframe::DataFrame, [id_column::Symbol], value_column::Symbol; kw_args...)\n\nPlots an outline of India, merged with the data passed in.  This data must fundamentally have two things: a column of IDs, and a column of values.  The IDs must match the IDs in the CPHS database,  and the values may be either numbers, or explicit colors.\n\nArguments\n\nadmin_level must be one of :State, :HR, or :District.  \n\nids must be a Vector{Union{Int, Missing}} or a Vector{Int}.  It and vals must have the same length.\n\nAttributes\n\nOne can set the attributes of the various plot elements by setting the values of the corresponding nested Attributes.  These are plot.State, plot.HR, plot.District, and plot.River.\n\nFor example, to set the stroke width of districts to 0.25, one would do:\n\nplot.District.strokewidth[] = 0.25\n\nThe attributes available for State, HR, and District are those of poly; the attributes available for River are those of lines.\n\nCropping the map to provided data\n\nIf the attribute crop_to_data is true, then this crops the map to the bounding box of the provided IDs only, and does not draw any other states/HRs/districts. Otherwise, all available geometries are drawn, but only the provided IDs are colored by their values; the rest of the geometries remain transparent.\n\nControlling how the data is merged\n\nYou can control the column on which data is merged by setting the merge_column and external_merge_column keyword arguments.\n\nmerge_column specifies the key with which to merge of the provided ids to the CPHS database for that admin level.\nexternal_merge_column specifies the key with which to merge the provided ids with the lower admin level geometries.  \n\nFor example, if the provided admin_level is :State, then merge_column will control the key for state_df, and external_merge_column will control the key for hr_df and district_df.\n\nTo see all available attributes and their defaults, have a look at the extended help section by running ??indiaoutline! in the REPL.\n\nExtended help\n\nAvailable attributes, and their values\n\nAvailable attributes and their defaults for MakieCore.Combined{Karmana.indiaoutline!} are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.indiaoutline-Tuple","page":"Plotting","title":"Karmana.indiaoutline","text":"indiaoutline!(admin_level::Symbol, ids::Vector, vals::Vector{<: Real}; kw_args...)\nindiaoutline!(admin_level::Symbol, dataframe::DataFrame, [id_column::Symbol], value_column::Symbol; kw_args...)\n\nPlots an outline of India, merged with the data passed in.  This data must fundamentally have two things: a column of IDs, and a column of values.  The IDs must match the IDs in the CPHS database,  and the values may be either numbers, or explicit colors.\n\nArguments\n\nadmin_level must be one of :State, :HR, or :District.  \n\nids must be a Vector{Union{Int, Missing}} or a Vector{Int}.  It and vals must have the same length.\n\nAttributes\n\nOne can set the attributes of the various plot elements by setting the values of the corresponding nested Attributes.  These are plot.State, plot.HR, plot.District, and plot.River.\n\nFor example, to set the stroke width of districts to 0.25, one would do:\n\nplot.District.strokewidth[] = 0.25\n\nThe attributes available for State, HR, and District are those of poly; the attributes available for River are those of lines.\n\nCropping the map to provided data\n\nIf the attribute crop_to_data is true, then this crops the map to the bounding box of the provided IDs only, and does not draw any other states/HRs/districts. Otherwise, all available geometries are drawn, but only the provided IDs are colored by their values; the rest of the geometries remain transparent.\n\nControlling how the data is merged\n\nYou can control the column on which data is merged by setting the merge_column and external_merge_column keyword arguments.\n\nmerge_column specifies the key with which to merge of the provided ids to the CPHS database for that admin level.\nexternal_merge_column specifies the key with which to merge the provided ids with the lower admin level geometries.  \n\nFor example, if the provided admin_level is :State, then merge_column will control the key for state_df, and external_merge_column will control the key for hr_df and district_df.\n\nTo see all available attributes and their defaults, have a look at the extended help section by running ??indiaoutline! in the REPL.\n\nExtended help\n\nAvailable attributes, and their values\n\nAvailable attributes and their defaults for MakieCore.Combined{Karmana.indiaoutline} are: \n\n  District               Attributes with 7 entries:\n  label => Districts\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGB{N0f8}(0.549,0.549,0.549)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 98\n  HR                     Attributes with 7 entries:\n  label => HR regions\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGBA{Float32}(0.901961,0.623529,0.0,1.0)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 99\n  Legend                 Attributes with 2 entries:\n  draw => true\n  polypoints => 1\n  River                  Attributes with 5 entries:\n  color => RGB{N0f8}(0.678,0.847,0.902)\n  label => Rivers\n  linewidth => 0.2\n  visible => true\n  zlevel => 97\n  State                  Attributes with 7 entries:\n  label => States\n  names => false\n  nan_color => RGBA{Float32}(0.0,0.0,0.0,0.0)\n  strokecolor => RGB{N0f8}(0.0,0.0,0.0)\n  strokewidth => 0.2\n  visible => true\n  zlevel => 101\n  colormap               :viridis\n  colorrange             MakieCore.Automatic()\n  crop_to_data           false\n  external_merge_column  MakieCore.Automatic()\n  highclip               \"nothing\"\n  lowclip                \"nothing\"\n  merge_column           MakieCore.Automatic()\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.latlong_string_to_points-Tuple{AbstractString}","page":"Plotting","title":"Karmana.latlong_string_to_points","text":"latlong_string_to_points(latlong_string)\n\nParses a string of the form lat1,long1 : lat2,long2 : lat3,long3 : ...  and returns a Vector of Point2e which define points as (long, lat).  \n\nIs robust to cutoff errors and other potential issues.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.line_to_geodetic_width_poly-Tuple{Vector{<:GeometryBasics.Point2}, Any}","page":"Plotting","title":"Karmana.line_to_geodetic_width_poly","text":"line_to_geodetic_width_poly(line::Vector{<: Point2}, width; geodesic = Proj.geod_geodesic(6378137, 1/298.257223563))\n\nReturns a Vector{Point2{Float64}} which represents a polygon which is width metres wide, and follows the path of line.\n\nThis is mostly useful for tracing wide lines on Raster maps.\n\nFundamentally, you can think of this function as creating a polygon from a line, with a specified width.  There's no interpolation, though -  if you want interpolation, pass an interpolated vector of points in.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.maps_db_connection","page":"Plotting","title":"Karmana.maps_db_connection","text":"maps_db_connection(user = ENV[\"MAPS_USER\"], password = ENV[\"MAPS_PASSWORD\"])::DBInterface.Connection\n\nReturns a connection to the maps database on data.mayin.org, which must be closed by DBInterface.close!.\n\n\n\n\n\n","category":"function"},{"location":"plotting/#Karmana.merge_polys-Tuple{AbstractVector}","page":"Plotting","title":"Karmana.merge_polys","text":"merge_polys(polys::AbstractVector{<: Union{Polygon, MultiPolygon}})\n\nMerges a vector of polygons into a single MultiPolygon using ArchGDAL.union.\n\nReturns an ArchGDAL geometry.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.nearest_paper_size-Tuple{Real, Real}","page":"Plotting","title":"Karmana.nearest_paper_size","text":"nearest_paper_size(width::Real, height::Real)::Symbol\n\nReturns the closest paper size to the provided size, which must be a 2-tuple.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.points_weights-Tuple{Any, Any}","page":"Plotting","title":"Karmana.points_weights","text":"points_weights(latlong_strings::Vector{:< AbstractString}, costs::Vector{<: Real})\n\nParses strings of the form lat1,long1 : lat2,long2 : lat3,long3 : ...  and returns a Vector of Point2e which define points as (long, lat), as well as a vector of weights per point.  If the string has more than one point defined,  the weight is spread across all n points such that each point has a weight of cost[i]/n.\n\nReturns (::Vector{Point2e}, ::Vector{<: Real}).\n\nnote: Note\nThis format of data is often found in CMIE capex location data.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.prepare_merged_river_geom-Tuple{Any, Any}","page":"Plotting","title":"Karmana.prepare_merged_river_geom","text":"prepare_merged_river_geom(shapefile_path, mask_poly)\n\nUses ArchGDAL to prepare a multilinestring which shows river paths within India.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.prepare_page-Tuple{Union{Symbol, Tuple{var\"#s100\", var\"#s100\"} where var\"#s100\"<:Real}, String}","page":"Plotting","title":"Karmana.prepare_page","text":"prepare_page(\n    paper_size::Union{Symbol, NTuple{2, <: Real}},\n    qr_code_contents::String;\n    landscape = false,\n    padding = 3,\n    logo = rotr90(FileIO.load(assetpath(\"logos\", \"XKDR_Logomark_RGB_White.jpg\"))),\n    logo_height = 40,\n    logo_padding = 5,\n    qr_code_height = 60,\n    qr_code_padding = 10,\n)\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.rgb_to_cmyk_pdf-Tuple{AbstractString, AbstractString}","page":"Plotting","title":"Karmana.rgb_to_cmyk_pdf","text":"rgb_to_cmyk_pdf(source_file::AbstractString, dest_file::AbstractString)\n\nRuns Ghostscript on source_file to convert its color schema from RGB to CMYK, and stores the result in dest_file.\n\nThis works well when preparing a PDF for printing, since many printer drivers don't perform the conversion as well as Ghostscript does.  You might see a  green tint on black when printing in color; this ameliorates that to a large degree.\n\nnote: Note\nConverting from RGB to CMYK is a lossy operation, since CMYK is a strict subset of RGB.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.searchsortednearest-Tuple{Any, Any}","page":"Plotting","title":"Karmana.searchsortednearest","text":"searchsortednearest(a, x)\n\nReturns the index of the nearest element to x in a. a must be a sorted array, and its elements must be mathematically interoperable with x.  \n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.shape_wkb_to_module_geom!-Tuple{Module, DataFrames.DataFrame}","page":"Plotting","title":"Karmana.shape_wkb_to_module_geom!","text":"shape_wkb_to_module_geom!(mod::Module, table::DataFrame; new_colname = :geometry, wkb_colname = :SHAPE_wkb)\n\nConverts the geometries in old_colname (in WKB format as eltype(old_colanme) = Vector{UInt8}) into geometries of the  provided module mod.  This goes through ArchGDAL instead of being pure-Julia with WellKnownGeometry, since that's faster.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.state_hr_district_dfs-Tuple{}","page":"Plotting","title":"Karmana.state_hr_district_dfs","text":"state_hr_district_dfs()\n\nA wrapper function which materializes the state, HR, and district dataframes in Julia, by connecting to the maps database of data.mayin.org.  \n\nReturns 3 DataFrames (state_table, hr_table, district_table) which all have columns :geometry populated by GeometryBasics geometry, which is suitable for plotting.\n\n\n\n\n\n","category":"method"},{"location":"plotting/#Karmana.target_point-NTuple{4, Any}","page":"Plotting","title":"Karmana.target_point","text":"target_point(lon, lat, azimuth, arclength; geodesic = Proj.geod_geodesic(6378137, 1/298.257223563))\n\nReturns a Makie.Point2f which represents the point at arclength metres from lon, lat in the direction of azimuth. Basically a thin wrapper around Proj's GeographicLib geod_directline.\n\njldoctest julia> target_point(0, 0, 0, 0) 2-element Point2{Float64} with indices SOneTo(2):  0.0  0.0`\n\n\n\n\n\n","category":"method"},{"location":"#Karmana","page":"Home","title":"Karmana","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Karmana.jl is a library which implements utilities to munge CMIE CPHS data and visualize it.  It exposes multiple, orthogonal capabilities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Karmana's visualization utilities are built on the Makie.jl ecosystem, including the GeoMakie.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is built to automate some processes to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Retrieve and process data from the CMIE CPHS and Capex databases\nPlot this data on maps of India.\nCreate coherent and good-looking posters of plots quickly and easily.","category":"page"},{"location":"#Installing","page":"Home","title":"Installing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Karmana.jl is meant to work with CMIE CPHS data, and is not meant to be released to the General registry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/xKDR/Karmana.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To add a specific branch or tag, provide the rev = \"branch_name\" keyword argument.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some functionality requires access to the xKDR maps database.  This can take one of two forms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Database credentials encoded in the environment variables \"MAPS_USER\" and \"MAPS_PASSWORD\".\nA shapefile whose location is indicated by the environment variable \"KARMANA_DISTRICT_SHAPEFILE\".\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can either set these before loading Karmana.jl, or call Karmana.__init__() after setting it to reset the state_df, hr_df, and district_df global variables (described below).","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Karmana.jl implements several orthogonal functions.  For more information, please see the documentation API page, or by running ?funcname in the REPL to access Julia's help mode.","category":"page"},{"location":"#Plotting-and-visualization","page":"Home","title":"Plotting and visualization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"create_page(page_size::Symbol, args...; kwargs...): Creates a Makie.jl figure which is optimized for a figure of the appropriate size, along with a \"header\" row (GridLayout) which has a logo and poster title, and a \"footer\" row (GridLayout) which has a description Label, space for a legend or colorbar, and a QR code with a customizable link.  See the documentation for more!\nindiaoutline!(admin_level::Symbol, ids, vals): A Makie.jl recipe which is able to plot at one of three admin levels (:State, :HR, and :District) - and display the other admin levels' borders.\nTernaryColormap(xgrad, ygrad, zgrad), which creates a \"ternary colormap\" that can be called on x, y, z values for which x + y + z = 1, and returns a ternary interpolated version of the color at the specified coordinates on the plane.","category":"page"},{"location":"#Global-variables","page":"Home","title":"Global variables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All of these variables are populated by Karmana.__init__(), and can their values can be accessed by, for example, Karmana.state_df[] (note the empty square brackets, which indicate that you're accessing the value of the Ref).","category":"page"},{"location":"","page":"Home","title":"Home","text":"state_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's states.\nhr_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's homogeneous regions, as defined by CMIE.\ndistrict_df::Ref{DataFrame}: A DataFrame which holds geometry data and identification keys for India's districts.\nindia_rivers::Ref{ArchGDAL.IGeometry}: An ArchGDAL.IGeometry which holds the intersection of the rivers of the world with the border of India.","category":"page"},{"location":"#CPHS-helper-functions","page":"Home","title":"CPHS helper functions","text":"","category":"section"},{"location":"#Capex-helper-functions","page":"Home","title":"Capex helper functions","text":"","category":"section"}]
}
